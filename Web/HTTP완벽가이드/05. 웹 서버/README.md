# 5장 웹 서버

이 장에서는 다음과 같은 내용을 다룬다.

- 여러 종류의 소프트웨어 및 하드웨어 웹 서버에 대해 조사한다.
- HTTP 통신을 진단해주는 간단한 웹 서버를 펄로 작성해본다.
- 어떻게 웹 서버가 HTTP 트랜책션을 처리하는지 단계별로 설명한다.

## 5.1 다채로운 웹 서버

- 웹 서버는 HTTP 요청을 처리하고 응답을 제공한다.
- 웹 서버는 기능, 크기 형태에 따라 다양하다.
- 기능은 달라도 모든 웹 서버는 리소스에 대한 HTTP 요청을 받아서 컨텐츠를 클라이언트에게 응답한다.

### 5.1.1 웹 서버 구현

- 웹 서버는 **HTTP + 관련 TCP 처리**를 구현한 것이다.
- 역할은 3가지: **HTTP 처리**, **리소스 관리**, **설정/통제/확장 같은 관리 기능 제공**
- **TCP 커넥션 관리는 OS와 분담**한다.
    - OS: TCP/IP 지원, 파일시스템, 프로세스/하드웨어 관리
    - 웹 서버: 커넥션을 받아 HTTP 요청/응답 흐름을 처리
- 구현 형태는 2가지가 흔하다.
    1. 일반 컴퓨터에 설치하는 **다목적 소프트웨어 웹 서버**
    2. 전자기기 안에 칩 형태로 들어가는 **임베디드(내장형) 웹 서버(관리 콘솔 제공)**

### 5.1.2 다목적 소프트웨어 웹 서버

- **표준 컴퓨터(서버) + 네트워크 환경**에서 동작하는 “일반형” 웹 서버다.
- **오픈소스**(예: Apache, W3C의 Jigsaw)도 있고, **상용**(예: Microsoft, iPlanet 계열 서버)도 있다.
- 거의 모든 컴퓨터/운영체제에서 돌아가고, 종류는 엄청 많지만 **실제로 널리 쓰이는 건 소수**다.
- Netcraft 조사(2014년 기준) 예시:
    - Microsoft 웹 서버: 약 **37%**
    - Apache 웹 서버: 약 **35%**
    - Nginx: 약 **14%** (최근 수년간 꾸준히 증가)

### 5.1.3 임베디드 웹 서버

- **프린터/가전 같은 소비자 제품에 내장**되는 **작은 웹 서버**다.
- 목적은 기기를 **웹 브라우저 UI로 쉽게 관리**하게 해주는 것(= 관리 콘솔 제공).
- 크기가 **1제곱인치도 안 될 정도로 매우 작을 수 있고**, 보통 **최소 기능만 제공**한다.

## 5.2 간단한 펄 웹 서버

- **완전한 HTTP 서버**는 생각보다 구현할 게 많다.
    - 예: Apache 웹 서버 코어만 **5만 줄+**이고, 모듈까지 합치면 더 커진다.
- HTTP/1.1 기능을 제대로 지원하려면

  **리소스 처리, 가상호스팅, 접근제어, 로깅, 설정, 모니터링, 성능 기능** 등이 필요하다.


이후 펄 웹 서버 구현은 생략

## 5.3 진짜 웹 서버가 하는 일

<img width="465" height="351" alt="image" src="https://github.com/user-attachments/assets/6f8ad1b3-e6c5-45a4-aea8-cc01b6b82e96" />

**현대 상용 웹 서버는 공통적으로 아래 7가지를 한다.**

1. **커넥션을 맺는다**: 클라이언트 접속을 받아들이거나, 원치 않으면 닫는다.
2. **요청을 받는다**: 네트워크에서 HTTP 요청 메시지를 읽는다.
3. **요청을 처리한다**: 요청을 해석하고 필요한 동작을 수행한다.
4. **리소스에 접근한다**: 요청이 가리키는 리소스를 찾고 가져온다.
5. **응답을 만든다**: 적절한 헤더를 포함한 HTTP 응답 메시지를 생성한다.
6. **응답을 보낸다**: 응답을 클라이언트에게 전송한다.
7. **로그를 남긴다**: 트랜잭션 완료 기록을 로그 파일에 남긴다.

> 다음 절들은 “웹 서버가 이 7단계를 각각 어떻게 수행하는지”를 설명한다.
>

## 5.4 단계 1: 클라이언트 커넥션 수락

- 클라이언트가 서버에 **이미 열린 지속 커넥션**이 있으면, 요청은 **그 커넥션을 재사용**한다.
- 지속 커넥션이 없으면, 요청을 보내기 위해 **새 TCP 커넥션을 새로 연다**.

### 5.4.1 새 커넥션 다투기

- 클라이언트가 웹 서버에 **TCP 커넥션을 요청**하면, 서버는 커넥션을 맺고 **IP 주소를 추출**해서 **누가 접속했는지** 확인한다.
- 커넥션을 **수락**하면, 서버는
    - 커넥션을 **커넥션 목록에 등록**하고
    - 해당 커넥션에서 오가는 데이터를 **감시/처리할 준비**를 한다.
- 서버는 커넥션을 **거절하거나 즉시 닫을 수 있다.**
    - 예: **인가되지 않은 IP/호스트**, 또는 **악성으로 알려진 클라이언트**면 종료
    - 필요하면 IP/호스트 외 **다른 신원 식별 방식**도 쓸 수 있다.

### 5.4.2 클라이언트 호스트명 식별

- 많은 웹 서버는 **역방향 DNS(reverse DNS)** 로 **클라이언트 IP → 호스트명** 변환을 하도록 설정할 수 있다.
- 이 호스트명은 보통 **접근 제어**나 **로깅**에 쓴다.
- 단점: **호스트명 lookup은 느릴 수 있어서** 웹 트랜잭션이 **눈에 띄게 느려질 수 있다.**
    - 그래서 대용량 서버는 보통 **기본 OFF** 하거나 **특정 콘텐츠에만 ON** 한다.
- Apache에서는 `HostnameLookups` 설정으로 호스트명 lookup을 켤 수 있고, 예시로 **HTML/CGI 리소스에만** 켜는 식의 제한 설정이 가능하다.

```jsx
HostnameLookups off
<Files ~ "\.(html|html|cgi)$"> 
	HostnameLookups on
</Files>
```

### 5.4.3 ident로 클라이언트 사용자 알아내기

- 일부 웹 서버는 **IETF ident 프로토콜**로 “이 HTTP 커넥션을 시작한 사용자 이름”을 알아낼 수 있다.
- 이 값은 **로그에 유용**해서, **Common Log Format**의 **두 번째 필드**에 ident 사용자명이 들어간다.

### 동작 방식(요지)

- 클라이언트가 HTTP 커넥션을 열면,
- 서버가 클라이언트의 ident 서비스(**TCP 113번 포트**)로 다시 접속해서
- “이 커넥션에 해당하는 사용자 이름이 뭐냐”를 묻는다.

### 공용 인터넷에서 잘 안 쓰이는 이유

- 클라이언트가 identd를 안 켜는 경우가 많다.
- lookup 때문에 **HTTP 트랜잭션이 느려진다.**
- 방화벽이 113 포트를 막는 경우가 많다.
- **안전하지 않고 조작이 쉽다.**
- 가상 IP 환경 지원이 약하다.
- 사용자 이름 노출로 **프라이버시 이슈**가 있다.

### Apache 설정/로그 처리

- Apache는 `IdentityCheck`로 ident lookup을 켤 수 있다.
- ident 정보가 없으면, 로그의 ident 필드는 보통 **(하이픈)** 으로 채워진다.

## 5.5 단계 2: 요청 메시지 수신

- 커넥션에 데이터가 오면, 웹 서버는 **바이트를 읽고 parsse** 해서 **HTTP 요청 메시지**를 만든다.

  <img width="463" height="211" alt="image" src="https://github.com/user-attachments/assets/2ad74b97-324c-44f4-9795-3949431f243f" />


### 파싱할 때 하는 일

- **요청줄(request line)** 파싱
    - `메서드` + `URI` + `HTTP 버전`
    - 값들은 **공백 1개로 구분**, 줄 끝은 **CRLF**
- **헤더(header)** 읽기
    - 헤더도 **한 줄씩 CRLF로 끝남**
- **빈 줄(CRLF만 있는 줄)** 찾기
    - 이게 **헤더 끝** 의미
- **본문(body)** 이 있으면 읽기
    - 길이는 보통 **`Content-Length`** 로 판단

### 현실적인 포인트

- 네트워크 입력은 **한 번에 깔끔하게 안 오고 들쭉날쭉** 들어온다.
- 커넥션은 **중간에 끊길 수도** 있다.
- 그래서 서버는 “파싱 가능한 만큼” 모일 때까지 데이터를 **메모리에 임시 버퍼링**해두고 조립해야 한다.

### 5.5.1 메시지의 내부 표현

- 웹 서버는 요청을 처리하기 쉽게 **요청 메시지를 내부 자료구조로 변환해 저장**하기도 한다.
- 예를 들어 내부 구조는:
    - 요청 메시지 각 부분(요청줄/헤더/바디)에 대한 **포인터 + 길이**를 들고 있고
    - 헤더는 **빠른 조회용 룩업 테이블(예: key-value map)** 에 저장해서 필드에 빠르게 접근한다.

<img width="475" height="268" alt="image" src="https://github.com/user-attachments/assets/f92f6c82-9b7d-4463-9af0-193a016703bf" />

### 5.5.2 커넥션 입력/출력 처리 아키텍처 (예시 포함 최종본)

- 웹 서버는 **수천 개 커넥션**을 동시에 열어두고, “요청이 느리게 오거나 / 대기 중이거나 / 폭주하는” 다양한 상태를 처리해야 한다.

<img width="464" height="431" alt="image" src="https://github.com/user-attachments/assets/a4339a21-de06-4b6f-9f69-1f6b7612127a" />

1. **단일 스레드 서버**
    - 한 번에 요청 1개만 처리, 끝나면 다음 처리
    - 구현은 쉽지만 처리 중엔 다른 커넥션이 전부 무시되어 성능이 나쁨
    - 로드가 적거나 진단 도구(type-o-serve) 정도에 적합
    - **예시:** `type-o-serve` 같은 테스트/진단용 서버(실서비스용 서버는 거의 이 구조로 안 씀)
2. **멀티프로세스/멀티스레드 서버**
    - 요청을 동시에 처리하려고 프로세스/스레드를 여러 개 사용
    - 방식: 필요할 때 생성하거나, 미리 풀로 만들어 둠
    - 단점: 커넥션마다 스레드/프로세스 할당하면 리소스(메모리/시스템) 폭증
    - 그래서 보통 최대 개수 제한을 둔다
    - **예시:** Apache HTTP Server(`prefork`/`worker`), Internet Information Services(Windows 웹서버)
3. **다중 I/O(멀티플렉싱) 서버**
    - 모든 커넥션을 동시에 감시하다가
    - “읽을 데이터 생김/에러 발생” 같은 상태 변화가 있을 때만 조금 처리
    - 처리 후 다시 감시 목록으로 복귀
    - 장점: 유휴 커넥션 때문에 스레드/프로세스가 기다리며 낭비하지 않음
    - **예시:** Nginx(대표적인 이벤트 기반 서버로 많이 언급됨)
4. **멀티스레드 + 다중화 서버**
    - 멀티스레딩 + 멀티플렉싱 결합
    - 여러 스레드가 커넥션(또는 커넥션 묶음)을 감시하며 조금씩 작업해서
    - CPU 여러 개 이점을 살리는 구조
    - **예시:** Undertow(IO threads + worker threads 구조), Apache HTTP Server의 `event` MPM(스레드 기반 + 이벤트 통지 성격)

## 5.6 단계 3: 요청 처리

- 웹 서버는 요청을 받으면 요청에서 **메서드 / 리소스 / 헤더 / 본문(있을 수도 없음)** 을 뽑아 해석하고 처리한다.
- 메서드마다 본문(entity body) 허용/요구 여부가 다르다.
    - **POST 등 일부 메서드**: 요청 본문이 **필수**
    - **OPTIONS 등 많은 메서드**: 본문이 **있어도 되지만 필수는 아님**
    - **GET 같은 일부 메서드**: 요청 본문이 **금지**되는 경우도 있다(책 표현)
- 이 책에서는 “요청 처리” 자체는 깊게 다루지 않는다.
    - 이유: **책의 나머지 대부분이 결국 ‘요청을 어떻게 처리하느냐’** 를 설명하는 내용이기 때문.

## 5.7 단계 4: 리소스 매핑과 접근

- 웹 서버는 **리소스 서버**다.
    - **정적 콘텐츠**(HTML, JPEG 같은 미리 만들어진 파일)도 제공하고
    - **동적 콘텐츠**(서버에서 실행되는 애플리케이션이 생성하는 결과)도 제공한다.
- 클라이언트에 콘텐츠를 보내려면 먼저,
    - 요청 메시지의 **URI(리소스 식별자)** 에 대응하는
    - **실제 콘텐츠(파일)** 또는 **콘텐츠 생성기(애플리케이션)** 를 서버에서 찾아
    - 그 **원천(source)** 을 식별해야 한다.

### 5.7.1 Docroot(문서 루트)

- 가장 단순한 리소스 매핑은 **요청 URI → 서버 파일 시스템의 파일 경로**로 매핑하는 방식이다.
- 이때 웹 콘텐츠를 모아둔 “특별한 폴더”를 **문서 루트(docroot)** 라고 부른다.
- 서버는 요청 URI를 **docroot 뒤에 그대로 붙여서** 실제 파일을 찾는다.

<img width="463" height="190" alt="image" src="https://github.com/user-attachments/assets/68a9c120-6bd7-49f4-847d-904c61180a55" />

예시

- docroot: `/usr/local/httpd/files`
- 요청 URI: `/specials/saw-blade.gif`
- 매핑 결과: `/usr/local/httpd/files/specials/saw-blade.gif`

**설정**

- Apache HTTP Server는 `httpd.conf`에서 `DocumentRoot`로 docroot를 지정한다.
    - `DocumentRoot /usr/local/httpd/files`

**보안 주의점**

- 서버는 URI가 `../` 같은 방식으로 **docroot 바깥 파일을 보게 되는 경로 탐색(path traversal)** 이 발생하지 않도록 막아야 한다.
    - 예: `http://www.joes-hardware.com/../` 같은 요청은 보통 허용하면 안 됨.

**가상 호스팅된 docroot**

- **가상 호스팅**은 한 웹 서버에서 **여러 웹사이트**를 운영하는 방식이고, 사이트마다 **서로 다른 docroot(문서 루트)** 를 준다.
- 서버는 요청의 **Host 헤더(또는 IP)** 를 보고 “어느 사이트 요청인지” 구분해서 **올바른 docroot** 를 선택한다.
- 그래서 한 서버 안에서도 사이트별 콘텐츠가 **완전히 분리**될 수 있다.

<img width="461" height="193" alt="image" src="https://github.com/user-attachments/assets/7b50dc1e-06d6-4ac4-be7b-2e16f6beb271" />

예시

- `www.joes-hardware.com` → `/docs/joe/index.html`
- `www.marys-antiques.com` → `/docs/mary/index.html`

<img width="467" height="250" alt="image" src="https://github.com/user-attachments/assets/1a3d9bc8-57a8-4815-8343-840af4a8146a" />

- Apache 설정 예시
- Apache HTTP Server에서는 사이트별 `VirtualHost` 블록에 `DocumentRoot`를 따로 둔다.

가상 호스팅(virtual hosting)은 **한 대의 웹 서버로 여러 웹사이트(도메인)를 동시에 서비스**하고, 요청의 **Host 헤더(또는 IP)** 로 사이트를 구분해 **각 사이트의 docroot/설정**을 적용하는 방식이다.

> 💡 가상 호스팅이란?
> - 가상 호스팅(virtual hosting)은 **한 대의 웹 서버로 여러 웹사이트(도메인)를 동시에 서비스**하고, 요청의 **Host 헤더(또는 IP)** 로 사이트를 구분해 **각 사이트의 docroot/설정**을 적용하는 방식이다.

**사용자 홈 디렉터리 docroot**

- docroot의 또 다른 활용은, **한 웹 서버에서 사용자마다 개인 웹사이트**를 만들 수 있게 해주는 것이다.

<img width="465" height="196" alt="image" src="https://github.com/user-attachments/assets/8681030b-47ff-4ee0-a619-3f26f83cb863" />

- 보통 URI가 **`/~사용자이름`** 형태로 시작하면, 그 사용자의 **개인 문서 루트(docroot)** 를 의미한다.
- 개인 docroot는 대개 사용자 홈 디렉터리 아래의 **`public_html`** 디렉터리로 매핑된다(서버 설정에 따라 달라질 수 있음).

### 5.7.2 디렉터리 목록

- 웹 서버는 URL이 **파일이 아니라 디렉터리**를 가리킬 때, 보통 아래 중 하나로 동작한다.
    - **에러 반환**
    - 디렉터리 대신 **특정 ‘색인 파일(index file)’** 반환
    - 디렉터리 내용을 훑어서 **목록(HTML 페이지)** 을 만들어 반환

**기본 동작: index 파일 찾기**

- 대부분 서버는 해당 디렉터리에서 `index.html` 또는 `index.htm` 같은 **기본 파일**을 먼저 찾는다.
- 있으면 그 파일을 반환한다.

**Apache 설정**

- Apache HTTP Server는 `DirectoryIndex`로 “디렉터리 요청 시 우선 찾을 파일 목록”을 설정할 수 있다.

예)

- `DirectoryIndex index.html index.htm home.html home.htm index.cgi`

**디렉터리 listing(자동 목록) 주의**

- 기본 색인 파일이 없고, 디렉터리 listing이 켜져 있으면
    - 서버가 파일명/크기/수정일/링크 등을 **자동으로 열거한 HTML**을 만들어 준다.
- 편하긴 하지만 **숨겨졌어야 할 파일까지 노출**될 수 있다는 위험이 있다.

**자동 목록 끄기(예)**

- `Options -Indexes`

### 5.7.3 동적 콘텐츠 리소스 매핑

- 웹 서버는 URI를 **정적 파일**뿐 아니라, 요청에 맞게 콘텐츠를 생성하는 **프로그램(동적 리소스)** 에도 매핑할 수 있다.
- 이런 동적 리소스를 처리하려고 웹 서버를 백엔드 애플리케이션과 연결해주는 시스템을 보통 **애플리케이션 서버**라고 부르기도 한다.

<img width="464" height="399" alt="image" src="https://github.com/user-attachments/assets/71c4dc9d-248d-4388-b320-e95035a358aa" />

- 동적 리소스라면 서버는
    - “생성 프로그램이 어디 있는지”
    - “어떻게 실행할지” 를 알아야 한다.

**Apache의 대표 매핑 방식 2가지**

1. **특정 경로(prefix)를 실행 디렉터리로 매핑**
- URI 경로가 특정 prefix로 시작하면, 대응 디렉터리에서 프로그램을 찾아 실행
- 예) `/cgi-bin/` 요청 → 서버의 CGI 프로그램 디렉터리에서 실행

```
ScriptAlias /cgi-bin/ /usr/local/etc/httpd/cgi-programs/
```

1. **특정 확장자만 실행하도록 매핑**
- `.cgi` 같은 확장자로 끝나는 리소스는 “파일로 내려주지 말고 실행”하라고 설정

```
AddHandler cgi-script .cgi
```

**CGI와 현대 방식**

- **CGI**는 초기 웹에서 널리 쓰인 “서버사이드 프로그램 실행 인터페이스”
- 요즘은 더 강력한 방식(예: Java Servlet, Active Server Pages 등)으로 동적 콘텐츠를 제공하는 애플리케이션 서버가 많이 쓰인다.

### 5.7.4 서버사이드 인클루드(SSI)

- 많은 웹 서버는 **SSI(Server-Side Includes)** 를 지원한다.
- 리소스가 SSI를 포함한다고 설정되어 있으면, 서버는 그 파일을 **그대로 보내지 않고**, 클라이언트에 보내기 전에 **한 번 처리**한다.
- 서버는 콘텐츠 안에서 “특별한 패턴”(보통 **특수한 HTML 주석 형태**)을 찾아서
    - **변수 값**이나
    - **내장 스크립트 실행 결과**

      로 **치환**한 뒤 응답한다.

- 즉, SSI는 **간단하게 동적 콘텐츠를 만드는 방법**이다.

---

### 5.7.5 접근 제어

- 웹 서버는 리소스별로 **접근 제어 규칙**을 붙일 수 있다.
- 접근 제어된 리소스 요청이 오면 서버는 예를 들어:
    - 클라이언트 **IP 주소 기반**으로 허용/차단하거나
    - 리소스 접근을 위한 **비밀번호(인증)** 를 요구할 수 있다.
- HTTP 인증은 12장에서 더 자세히 다룬다.

## 5.8 단계 5: 응답 만들기

- 서버가 리소스를 식별하면, 요청 메서드가 요구하는 동작을 수행한 뒤 **응답 메시지**를 만든다.
- 응답 메시지는 보통 아래로 구성된다.
    - **상태 코드(Status Code)**
    - **응답 헤더(Response Headers)**
    - **응답 본문(Response Body, 생성된 경우)**

### 5.8.1 응답 엔터티

- 트랜잭션이 **응답 본문(body)** 을 생성한다면, 서버는 그 내용을 응답 메시지와 함께 돌려보낸다.
- 응답에 본문이 있다면, 보통 아래 요소들이 포함된다.
    - `Content-Type`: 응답 본문의 **MIME 타입**
    - `Content-Length`: 응답 본문의 **길이**
    - 실제 **응답 본문 데이터**

### 5.8.2 MIME 타입 결정하기

- 웹 서버는 응답 본문의 **MIME 타입(Content-Type)** 을 결정할 책임이 있다.
- MIME 타입을 리소스에 매핑하는 대표 방법들:

**1) 확장자 기반(`mime.types`)**

- 파일 확장자(예: `.html`, `.jpg`)로 MIME 타입을 정한다.
- 확장자 ↔ MIME 타입 매핑이 들어있는 `mime.types` 같은 파일을 참고한다.
- **가장 흔한 방식**

  <img width="459" height="305" alt="image" src="https://github.com/user-attachments/assets/94f3577c-3f28-41d2-a0d5-0437738a86fc" />

**2) 매직 타이핑(Magic typing)**

- 파일 확장자가 아니라 **파일 내용(바이너리 패턴)** 을 검사해서 MIME 타입을 추정한다.
- Apache HTTP Server는 “매직 파일(magic file)” 테이블과 비교하는 방식 지원.
- 단점: **느리지만**, 확장자가 표준이 아니거나 없는 파일에 유용.

**3) 유형 명시(Explicit typing)**

- 특정 파일/디렉터리에 대해 확장자나 내용과 무관하게 “이건 이 타입이다”를 **서버 설정으로 강제**할 수 있다.

**4) 유형 협상(Type negotiation)**

- 하나의 리소스를 **여러 표현(형식)** 으로 준비해두고,
- 서버가 클라이언트와 협상해서(예: 어떤 형식을 선호하는지) **가장 적절한 형식 + MIME 타입**을 선택하게 할 수 있다.
- 추가로, 서버는 “특정 파일은 특정 MIME 타입”처럼 **개별 파일 단위**로도 설정 할 수 있다.

### 5.8.3 리다이렉션

- 웹 서버는 성공(200) 대신 **리다이렉션 응답(3xx)** 을 돌려줄 때가 많다.
- 리다이렉션은 “요청을 처리하려면 브라우저가 **다른 곳(다른 URI)** 으로 가라”는 의미다.
- 이때 응답의 `Location` 헤더에 **새 위치(URI)** 가 들어간다.

리다이렉션이 유용한 경우들

**1) 영구 이동(리소스가 완전히 옮겨짐)**

- 리소스 URL이 바뀌었으니 **북마크 갱신** 같은 걸 하라는 의미
- 보통 `301 Moved Permanently`

**2) 임시 이동(잠깐만 다른 곳)**

- 지금만 다른 위치로 보내되, **북마크는 바꾸지 말아라**
- 보통 `303 See Other`, `307 Temporary Redirect`

**3) URL 증강(상태 정보 붙이기)**

- 서버가 문맥/상태 정보를 포함한 **새 URL을 만들어** 그쪽으로 보내는 방식
- 클라이언트는 리다이렉트를 따라가서 “상태 정보가 포함된 URL”로 다시 요청
- 트랜잭션 간 **상태 유지**에 유용한 방법
- 보통 `303`, `307` 사용

**4) 부하 분산(Load balancing)**

- 서버가 과부하이면, 덜 바쁜 서버로 **보내버릴 수** 있다
- 보통 `303`, `307` 사용

**5) “친밀한” 다른 서버로 보내기**

- 어떤 사용자의 정보를 다른 서버가 더 잘 알고 있으면
- 그 서버로 리다이렉트해서 처리하게 할 수 있다
- 보통 `303`, `307` 사용

**6) 디렉터리 이름 정규화**

- 디렉터리 URL인데 끝의 `/`를 빠뜨리면
- 상대경로가 깨질 수 있어서 서버가 `/`를 붙인 URL로 **리다이렉트**한다
    - 예: `/docs` → `/docs/`

## 5.9 단계 6: 응답 보내기

- 웹 서버는 요청을 받을 때처럼, 응답을 보낼 때도 **여러 커넥션을 동시에 다루는 문제**를 겪는다.
    - 어떤 커넥션은 유휴 상태
    - 어떤 커넥션은 요청 데이터를 서버로 보내는 중
    - 어떤 커넥션은 서버가 응답 데이터를 클라이언트로 보내는 중
- 그래서 서버는 각 커넥션의 **상태를 추적**해야 하고, 특히 **지속 커넥션(persistent connection)** 은 더 신경 써야 한다.

**비지속 커넥션(non-persistent)**

- 서버는 **응답 메시지를 다 전송하면** 자기 쪽 커넥션을 닫는다.

**지속 커넥션(persistent)**

- 서버는 커넥션을 **열어둔 채로** 다음 요청을 받을 수 있다.
- 다만 지속 커넥션에서는 클라이언트가 “응답이 어디서 끝나는지” 알아야 해서,
    - `Content-Length`를 **정확히 계산**해야 하고,
    - 그렇지 않으면 클라이언트가 응답 종료를 판단 못 하는 문제가 생길 수 있다

## 5.10 단계 7: 로깅

- 트랜잭션이 완료되면, 웹 서버는 “이 요청/응답이 어떻게 처리됐는지”를 **로그 파일에 기록**한다.
- 대부분의 웹 서버는 로깅 방식에 대해 **여러 설정 옵션(형식/항목/저장 위치 등)** 을 제공한다.

