> ###  [인프런 - 모든 개발자를 위한 HTTP 웹 기본 지식](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard)을 보고 정리

    참고
    https://webstone.tistory.com/66 

<br>
<br>

# **HTTP 헤더 개요**

HTTP 전송에 필요한 모든 부가정보가 포함
- 예) 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트, 서버 정보, 캐
시 관리 정보...
- 표준 헤더가 너무 많음
- 필요시 임의의 헤더 추가 가능
    - ex) helloworld: hih

### **과거의 HTTP 헤더**
<img src="./item/HTTP헤더-RFC2616.png" width="650" height="400">

- 과거엔 헤더를 4가지로 분류
    - General 헤더: 메시지 전체에 적용되는 정보, 예) Connection: close
    - Request 헤더: 요청 정보, 예) User-Agent: Mozilla/5.0 (Macintosh; ..)
    - Response 헤더: 응답 정보, 예) Server: Apache
    - Entity 헤더: 엔티티 바디 정보, 예) Content-Type: text/html, Content-Length: 342

<img src="./item/HTTP헤더-RFC2616-2.png" width="370" height="200">

- 메시지 본문(message body)은 엔티티 본문(entity body)을 전달하는데 사용
- 엔티티 본문은 요청이나 응답에서 전달할 실제 데이터
- 엔티티 헤더는 엔티티 본문의 데이터를 해석할 수 있는 정보 제공
    - 데이터 유형(html, json), 데이터 길이, 압축 정보 등등
---

```
RFC2616이 폐지 되고 
2014년 RFC7230~7235 등장 하여 스펙 변경 됨 
```
**RFC723x 변화**
- **엔티티(Entity)가 표현(Representation)으로 변경**
- Representation = representation Metadata + Representation Data
- 표현 = 표현 메타데이터 + 표현 데이터

HTTP BODY // message body - RFC7230(최신)

<img src="./item/HTTP헤더-RFC7230.png" width="370" height="200">

- 메시지 본문(message body)을 통해 표현 데이터 전달
- 메시지 본문을 페이로드(payload)라고 한다.
- 표현은 요청이나 응답에서 전달할 실제 데이터
- 표현 헤더는 표현 데이터를 해석할 수 있는 정보 제공
    - 데이터 유형(html, json), 데이터 길이, 압축 정보 등등
- 참고: 표현 헤더는 표현 메타데이터와, 페이로드 메시지를 구분해야 하지만, 여기서는 생략

- 표현헤더 + 표현 데이터 = 표현 

> 리소스가 HTML로 표현 될수도, JSON으로 표현 될수도 있기 때문에 표현이란 단어를 사용한다고 함

# **표현 - Content 헤더**
HTTP 메시지(요청과 응답 모두)에 담겨 보내는 데이터의 형식을 알려주는 헤더이다.

- **Content-Type**: 표현 데이터의 형식
    - 미디어 타입, 문자 인코딩.
        - 예)
            - text/html; charset=utf-8
            - application/json (default가 utf-8)
            - image/png
- **Content-Encoding**: 표현 데이터의 압축 방식
    - 표현 데이터를 압축하기 위해 사용
    - 데이터를 전달하는 곳에서 압축 후 인코딩 헤더 추가
    - 데이터를 읽는 쪽에서 인코딩 헤더의 정보로 압축 해제
        - 예)
            - gzip
            - deflate
            - identity : 압축 x
- **Content-Language**: 표현 데이터의 자연 언어
    - 예 ) ko를 브라우저에서 사용중 인데 Content의 언어가 en이면 언어 변경 여부 물어볼 수 있음.
    - 예)
        - ko
        - en
        - en-US
- **Content-Length**: 표현 데이터의 길이
    - 바이트 단위
    - Transfer-Encoding(전송 코딩)을 사용하면 Content-Length를 사용하면 안됨

<br>

    - 표현 헤더는 전송, 응답 둘다 사용
    - Content-Type헤더가 없다면 데이터를 받는 입장에서는 단순히 텍스트 데이터로 받아들인다. 
    - GET방식은 쿼리스트링으로 value=text형식으로 보내 진다는 걸 알기 떄문에 content-type이 필요 없다.
    - Content-Type은 POST나 PUT처럼 메시지 BODY에 데이터를 보낼때 필요로 한다.  

# **콘텐츠 협상 - Accept 헤더**

브라우저(클라이언트) 에서 웹서버로 요청시 **요청메시지에 담기는 헤더**이다.

이 Accept헤더는 쉽게 말해 자신에게 이러한 데이터 타입만 허용하겠다는 뜻입니다.

- Accept: 클라이언트가 선호하는 미디어 타입 전달
- Accept-Charset: 클라이언트가 선호하는 문자 인코딩
- Accept-Encoding: 클라이언트가 선호하는 압축 인코딩
- Accept-Language: 클라이언트가 선호하는 자연 언어


    - Accept 헤더는 요청시에만 사용
    - 간단히 하면 클라이언트가 서버로 부터 어떤 타입을 응답 받고 싶다고 요청하는것
    - 서버가 지원안하면 어쩔수 없음.
- ex) Accept-Language로 선호 언어를 지정해주면 Content-Language를 선호 언어로 보내준다. 

### **Accept헤더 우선순위**
> 한국어(ko)를 Accept-Language로 요청 했는데 서버는 독일어와 영어밖에 지원 안할때, 영어(en)로 라도 응답 받고싶을떄 우선순위 적용 하여 전송 
- Quality Values(q) 값 사용
-  0~1, **클수록 높은 우선순위**
-  생략하면 1
-  Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
    -  1순위.ko-KR;q=1 (q생략)
    -  2순위.ko;q=0.9
    -  3순위.en-US;q=0.8
    -  4순위.en:q=0.7
- **구체적인 것이 우선시 한다.**
    - Accept: text/*, text/plain, text/plain;format=flowed, */*
        - 1순위.text/plain;format=flowed
        - 2순위.text/plain
        - 3순위.text/*   
        - 4순위.*/*
- **구체적인 것을 기준으로 미디어 타입을 맞춘다**
- 다른 Accept 헤더에도 우선순위 설정 가능 

### Content 타입과 Accept 타입의 차이점
    Content-Type 헤더와 Accept 헤더 둘 다 데이터 타입(MIME)을 다루는 헤더이다. 
    하지만  Content-Type 헤더는 현재 전송하는 데이터가 어떤 타입인지에 대한 설명을 하는 개념이고  Accept 헤더는 클라이언트가 서버에게 어떤 특정한 데이터 타입을 보낼때  클라이언트가 보낸 특정 데이터 타입으로만 응답을 해야한다.

# **전송 방식**

- **단순 전송 - Cotent-Length**
    - 한번에 요청하고 한번에 전부 받는다 // Content-Length를 알고 있을떄 
```
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF-8
Content-Length: 3423

<html>
 <body>...</body>
</html>
```
- **압축 전송 - Cotent-Encoding**
    - 압축해서 보낸다.
    - Content-Encoding으로 어떠한 방식으로 압축했는지 지정 필요

```
EX)
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF-8
Content-Encoding: gzip
Content-Length: 521

lkj123kljoiasudlkjaweioluywlnfdo912u34ljko98udjkl
```

- **분할 전송**
    - Chunk : 덩어리 
    - 용량이 클떄 몇 바이트씩 잘라서 보낼수 있음. 
    - 분할 전송일떄는 Content-Length를 보내면 안된다. 
        - Content-Length를 예상할 수 없다.
        - Check마다 이미 바이트 값(길이)이 명시되어 있음.
    - **Transfer-Encoding: chunked 표기됨** 
```
EX) 
HTTP/1.1 200 OK
Content-Type: text/plain
Transfer-Encoding: chunked

5
Hello
5
World
0
\r\n
```
- **범위 전송**

해당 데이터 부터 받겠다고 지정 가능 
> ex) 이미지를 전송 받다가 중간에 끊켰는데 다시 처음부터 받으면 용량이 아깝기 떄문에 나머지 데이터 범위 부터 전송 받을수 있다. 

요청 시 - Range 지정
```
GET /event
Range: bytes=1001-2000
```
응답 시 - Content-Range 표기
```
HTTP/1.1 200 OK
Content-Type: text/plain
Content-Range: bytes 1001-2000 / 2000

qweqwe1l2iu3019u2oehj1987askjh3q98y
```

# **일반 정보**

**단순한 정보성 헤더들**

- From: 유저 에이전트의 이메일 정보
    - 일반적으로 잘 사용되지 않음
    - 검색 엔진 같은 곳에서, 주로 사용
    - 요청에서 사용
- Referer: 이전 웹 페이지 주소
    - 현재 요청된 페이지의 이전 웹 페이지 주소
    - A -> B로 이동하는 경우 B를 요청할 때 Referer: A 를 포함해서 요청
    - Referer를 사용해서 유입 경로 분석 가능
    - **요청에서 사용**
    - 참고: referer는 단어 referrer의 오타
- User-Agent: 유저 에이전트 애플리케이션 정보
    - user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/
537.36 (KHTML, like Gecko) Chrome/86.0.4240.183 Safari/537.36
    - 클리이언트의 애플리케이션 정보(**웹 브라우저 정보**, 등등)
    - 통계 정보
    - 어떤 종류의 브라우저에서 장애가 발생하는지 파악 가능
    - **요청에서 사용**
- Server: 요청을 처리하는 오리진 서버의 소프트웨어 정보
    - 요청 시 중간에 여러 프록시 서버를 거치는데 ORIGIN서버는 HTTP요청을 실제 처리해 주는 서버를 말한다. 
    - Server: Apache/2.2.22 (Debian)
    - server: nginx
    - **응답에서 사용**
- Date: 메시지가 생성된 날짜
    - Date: Tue, 15 Nov 1994 08:12:31 GMT
    - **응답에서 사용**

# **특별한 정보**

애플리케이션에 영향이 있는 특별한 헤더들