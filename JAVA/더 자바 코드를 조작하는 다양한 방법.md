# JVM 이해하기

## **1.자바, JVM, JDK, JRE**

![image](https://user-images.githubusercontent.com/70142711/215266483-7e0766ea-1064-43d6-b7c9-8673ef06d08b.png)

JVM (Java Virtual Machine)

- 자바 가상 머신으로 자바 바이트 코드(.class 파일)를 OS에 특화된 코드로 변환(인터프리터와 JIT 컴파일러)하여 실행한다.
- 바이트 코드를 실행하는 표준(JVM 자체는 표준)이자 구현체(특정 밴더가 구현한 JVM)다.
- JVM 스팩: [https://docs.oracle.com/javase/specs/jvms/se11/html/](https://docs.oracle.com/javase/specs/jvms/se11/html/)
- JVM 밴더: 오라클, 아마존, Azul, ...
- 특정 플랫폼에 종속적.

JRE (Java Runtime Environment): JVM + 라이브러리

- 자바 애플리케이션을 실행할 수 있도록 구성된 배포판.
- JVM과 핵심 라이브러리 및 자바 런타임 환경에서 사용하는 프로퍼티 세팅이나 리소스 파일을 가지고 있다.
- 개발 관련 도구는 포함하지 않는다. (그건 JDK에서 제공)
    - javac는 제공하지 않는다.

JDK (Java Development Kit): JRE + 개발 툴

- JRE + 개발에 필요할 툴
- 소스 코드를 작성할 때 사용하는 자바 언어는 플랫폼에 독립적.
- 오라클은 자바 11부터는 JDK만 제공하며 JRE를 따로 제공하지 않는다.
- Write Once Run Anywhere

자바

- 프로그래밍 언어
- JDK에 들어있는 자바 컴파일러(javac)를 사용하여 바이트코드(.class 파일)로 컴파일 할 수 있다.
- 자바 유료화? 오라클에서 만든 Oracle JDK 11 버전부터 상용으로 사용할 때 유료.
    - [https://medium.com/@javachampions/java-is-still-free-c02aef8c9e04](https://medium.com/@javachampions/java-is-still-free-c02aef8c9e04)

JVM 언어

- JVM 기반으로 동작하는 프로그래밍 언어
- 클로저, 그루비, JRuby, Jython, Kotlin, Scala, ...

```java
javap -c 컴파일된클래스파일
```

위 명령어로 컴파일된 class파일을 확인 할 수 있다.

JVM기반으로 된 JVM언어는 결국 class파일을 만들거나, java파일을 만들게 된다.

참고

- JIT 컴파일러: [https://aboullaite.me/understanding-jit-compiler-just-in-time-compiler/](https://aboullaite.me/understanding-jit-compiler-just-in-time-compiler/)
- JDK, JRE 그리고 JVM: [https://howtodoinjava.com/java/basics/jdk-jre-jvm/](https://howtodoinjava.com/java/basics/jdk-jre-jvm/)
- [https://en.wikipedia.org/wiki/List_of_JVM_languages](https://en.wikipedia.org/wiki/List_of_JVM_languages)

---

## JVM 구조

![image](https://user-images.githubusercontent.com/70142711/215266502-eceb4181-c6c2-4a5c-9680-5325d8e33942.png)

클래스 로더 시스템

- .class 에서 바이트코드를 읽고 메모리에 저장
- 로딩: 클래스 읽어오는 과정
- 링크: 레퍼런스를 연결하는 과정
- 초기화: static 값들 초기화 및 변수에 할당

메모리

- `메소드 영역`에는 클래스 수준의 정보 (클래스 이름, 패키지 경로, 부모 클래스 이름, 메소드, 변수) 저장. 공유 자원이다.
    - 다른 영역에서 참조 할 수 있다.
- `힙 영역`에는 객체를 저장. 공유 자원이다.

아래 세 영역은 스레드에 국한 된 영역

- `스택 영역`에는 쓰레드 마다 `런타임 스택`을 만들고, 그 안에 메소드 호출을 `스택 프레임이라 부르는 블럭으로 쌓는다.` 쓰레드 종료하면 런타임 스택도 사라진다.
- `PC(Program Counter) 레지스터`: 쓰레드 마다 쓰레드 내 현재 실행할 instruction의 위치를 가리키는 포인터가 생성된다.
- `네이티브 메소드 스택`
    - `Java가 아닌 다른 언어로 작성된 코드를 위한 공간`
    - 자바 프로그램이 컴파일되어 생성되는 바이트 코드가 아닌 실제 수행할 수 있는 기계어로 작성된 프로그램을 실행 시키는 영역
- [https://javapapers.com/core-java/java-jvm-run-time-data-areas/#Program_Counter_PC_Register](https://javapapers.com/core-java/java-jvm-run-time-data-areas/#Program_Counter_PC_Register)

실행 엔진

- 인터프리터: 바이트 코드를 한줄 씩 실행.
    - 바이트 코드를 네이티브 코드로 한줄 한줄 컴파일해서 실행
- JIT 컴파일러: 인터프리터 효율을 높이기 위해, 인터프리터가 반복되는 코드를 발견하면 JIT 컴파일러로 반복되는 코드를 모두 네이티브 코드로 바꿔둔다. 그 다음부터 인터프리터는 네이티브 코드로 컴파일된 코드를 바로 사용한다.
- GC(Garbage Collector): 더이상 참조되지 않는 객체를 모아서 정리한다.
    - 쓰로우 풋(처리량) 위주의 GC 와 stop the world 를 줄이는 GC 두가지가 있다
    - 많은 객체를 생성하고, response 타임이 중요하면 stop the world를 줄이는 GC사용
        - GC를 수행하면서 발생하는 pause time(멈춤 현상)이 최소화 되는
    - [https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html)
    - GC 종류
        
        [NAVER D2](https://d2.naver.com/helloworld/1329)
        

JNI(Java Native Interface)

- 자바 애플리케이션에서 C, C++, 어셈블리로 작성된 함수를 사용할 수 있는 방법 제공
- Native 키워드를 사용한 메소드 호출
- [https://medium.com/@bschlining/a-simple-java-native-interface-jni-example-in-java-and-scala-68fdafe76f5f](https://medium.com/@bschlining/a-simple-java-native-interface-jni-example-in-java-and-scala-68fdafe76f5f)

네이티브 메소드 라이브러리

- C, C++로 작성 된 라이브러리

네이티브 메소드 라이브러리를 사용하려면 JNI를 통해야하고, JNI를 사용하는 메서드 스택은 네이티브 메서드 스택에 저장이 된다.

네이티브 메서드

Native키워드가 붙어있고, 구현을 C나 C++로 한 메서드

```java
Thread.currentThread();

// Thread클래스 내부
public static native Thread currentThread(); // 선언부를 보면 native 키워드가 붙어 있다.
```

참고

- [https://www.geeksforgeeks.org/jvm-works-jvm-architecture/](https://www.geeksforgeeks.org/jvm-works-jvm-architecture/)
- [https://dzone.com/articles/jvm-architecture-explained](https://dzone.com/articles/jvm-architecture-explained)
- [http://blog.jamesdbloom.com/JVMInternals.html](http://blog.jamesdbloom.com/JVMInternals.html)

---

## 클래스 로더

![image](https://user-images.githubusercontent.com/70142711/215266519-33e897ea-26d1-4ae6-8884-0001d138b38f.png)

클래스 로더

- 로딩, 링크, 초기화 순으로 진행된다.
- 로딩
    - 클래스 로더가 .class 파일을 읽고 그 내용에 따라 적절한 바이너리 데이터를 만들고 `“메소드”` 영역에 저장.
    - 이때 메소드 영역에 저장하는 데이터
        - FQCN(**Full Qualified Class Name**)
            - 클래스가 속한 패키지명을 모두 포함한 이름
        - 클래스 | 인터페이스 | 이늄
        - 메소드와 변수
    - `로딩이 끝나면 해당 클래스 타입의 Class 객체를 생성하여 “힙" 영역에 저장.`

- 링크
    - Verify, Prepare, Reolve(optional) 세 단계로 나눠져 있다.
    - Verify(검증): .class 파일 형식이 유효한지 체크한다.
    - Preparation: 클래스 변수(static 변수)와 기본 값에 필요한 메모리를 준비하는 과정
    - Resolve: 심볼릭 메모리 레퍼런스를 메소드 영역에 있는 실제 레퍼런스로 교체한다.
        
        ```java
        public class App {
            Book book = new Book();
        }
        ```
        
        - 위의 클래스를 읽어도 book변수에는 실제 Book객체를 가리키지 않고 심볼릭 레퍼런스이다.
        - 실제 Heap에 들어있는 Book객체 인스턴스를 가리키도록 한다.
        - Resolve는 이떄 발생할 수도 있고, 이떄 발생하지 않을 수도 있다고 함
        - **헷갈리는 포인트**
            - 인프런 질문
                
                현재 링크의 Resolve 설명에서 `심볼릭 메모리 레퍼런스를 메소드 영역에 있는 실제 레퍼런스로 교체한다.`라고 명시되어 있습니다.
                
                메소드 영역은 클래스 정보만을 저장하는 영역이라 알고 있어서 메소드 영역이 아니고 힙 영역이라고 맞다고 생각이 드는데, 이것이 맞는지 궁금합니다.
                
            - 기선님 답변
                
                수업 50초에서 설명하지만, 메소드 영역이라는 메모리에는 클래스 정보가 담기는데, 그 "클래스 정보"에 클래스가 담고 있는 메소드에 대한 정보도 들어있습니다. 그러니 메소드 영역에 있는 실제 레퍼런스를 참조하도록 바꾸는게 맞는거고 힙 영역을 참조하는게 아닙니다.
                
            
- 초기화
    - Static 변수의 값을 할당한다. (static 블럭이 있다면 이때 실행된다.)
        
        `Preparation` 과정에서 준비한 메모리 영역에다 static한 변수의 값을 할당하는 과정
        
        ```java
        public class App {
            static String name = "jinhyeon";
        }
        static {
                
        }
        ```
        
        이런 static변수나 static 블록은 이 과정 에서 할당 된다.
        
        - static블록은 클래스가 로딩될떄 한번 만 실행 된다.
            
            [[Java] static method, static block - Onsil's blog](https://onsil-thegreenhouse.github.io/programming/java/2017/11/12/java_static_method_block/)
            
        
- 클래스 로더는 계층 구조로 이뤄져 있으면 기본적으로 세가지 클래스 로더가 제공된다.
    - 부트 스트랩 클래스 로더 - JAVA_HOME\lib에 있는 코어 자바 API를 제공한다. 최상위 우선순위를 가진 클래스 로더
    - 플랫폼 클래스로더 - JAVA_HOME\lib\ext 폴더 또는 java.ext.dirs 시스템 변수에 해당하는 위치에 있는 클래스를 읽는다.
        - Extension 클래스 로더(java9이상)라고도 하고 Platform 클래스 로더(java8이전)라고도 함
    - 애플리케이션 클래스로더 - 애플리케이션 클래스패스(애플리케이션 실행할 때 주는 -classpath 옵션 또는 java.class.path 환경 변수의 값에 해당하는 위치)에서 클래스를 읽는다.
- 

```java
App.class.getClassLoader()
```

- App클래스를 읽어들인 클래스로더 종류 확인 가능

```java
public class App {
    public static void main(String[] args) {
        ClassLoader classLoader = App.class.getClassLoader();
        System.out.println(classLoader);
        System.out.println(classLoader.getParent());
        System.out.println(classLoader.getParent().getParent());
    }
}
```

```java
jdk.internal.loader.ClassLoaders$AppClassLoader@2437c6dc
jdk.internal.loader.ClassLoaders$PlatformClassLoader@35f983a6
null
```

App클래스의 클래스로더는 `어플리케이션 클래스 로더`

어플리케이션 클래스 로더 의 부모는 `플랫폼 클래스 로더`

플랫폼 클래스 로더의 부모는 `Bootstrap 클래스로더인데 볼 수가 없음.` 

- 있긴 있는데 볼수가 없음, Native코드로 구현이 되어 있어서

```java
String append = VM.getSavedProperty("jdk.boot.class.path.append");
        BOOT_LOADER =
            new BootClassLoader((append != null && !append.isEmpty())
                ? new URLClassPath(append, true)
                : null);
        PLATFORM_LOADER = new PlatformClassLoader(BOOT_LOADER);
```

부트로더는 프로퍼티값에 설정되어있는 클래스 패스에 속해있는 클래스들만 읽는다.

```java
String cp = System.getProperty("java.class.path");
        if (cp == null || cp.isEmpty()) {
            String initialModuleName = System.getProperty("jdk.module.main");
            cp = (initialModuleName == null) ? "" : null;
        }
        URLClassPath ucp = new URLClassPath(cp, false);
        APP_LOADER = new AppClassLoader(PLATFORM_LOADER, ucp);
```

어플리케이션 클래스 로더는 ``java.class.path`` 또는 ``jdk.module.main`` 에서 값을 가져와서 그 클래스 패스에 있는 것들을 읽는다.

우리가 작성하는 클래스는 99%의 경우에는 `어플리케이션 클래스로더를 사용하여 클래스를 읽는다`

어플리케이션 클래스 로더는 기본적으로 부모 클래스 로더에게 읽는걸 요청한 후 부모 클래스 로더가 못읽으면 그떄 본인이 읽는다.

- 어플리케이션 클래스 로더도 못읽으면 ClassNotFoundException 발생

- 클래스 로더 상세 설명
    
    [[Java] JVM의 클래스 로더란?](https://steady-coding.tistory.com/593)
---
# 바이트 코드 조작 
## 코드 커버리지는 어떻게 측정할까?

코드 커버리지란?

- 테스트 코드가 확인한 소스 코드를 %
- 테스트 코드로 소스코드를 얼만큼 확인했는지

- JaCoCo를 써보자.
- [https://www.eclemma.org/jacoco/trunk/doc/index.html](https://www.eclemma.org/jacoco/trunk/doc/index.html)
- [http://www.semdesigns.com/Company/Publications/TestCoverage.pdf](http://www.semdesigns.com/Company/Publications/TestCoverage.pdf)

pom.xml에 플러그인 추가

```java
<plugin>
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <version>0.8.4</version>
    <executions>
        <execution>
            <goals>
                <goal>prepare-agent</goal>
            </goals>
        </execution>
        <execution>
            <id>report</id>
            <phase>prepare-package</phase>
            <goals>
                <goal>report</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

`메이븐 빌드

```java
mvn clean verify
```

나의 경우 target/site 경로가 생기지 않았고 

mvn site를 따로 실행하니 target/site파일 생성 되었음 

target/site/index.html 파일을 실행 

커버리지 만족 못할시 빌드 실패하도록 설정

```java
<execution>
    <id>jacoco-check</id>
    <goals>
        <goal>check</goal>
    </goals>
    <configuration>
        <rules>
            <rule>
                <element>PACKAGE</element>
                <limits>
                    <limit>
                        <counter>LINE</counter>
                        <value>COVEREDRATIO</value>
                        <minimum>0.50</minimum>
                    </limit>
                </limits>
            </rule>
        </rules>
    </configuration>
</execution>
```

![image](https://user-images.githubusercontent.com/70142711/216076131-7468a20f-bde1-4628-8e53-fa4e7b9e0b06.png)

- 노란 부분은 모든 조건을 타지못하고 일부분만 테스트 했을때
    - maxNumberOfAttendess가 0인 경우와 0이 아닌 경우를 다 테스트해야 한다.
- 빨간 부분은 한번도 도달하지 못했을 때
- 초록 부분은 커버리지 채웠다는 뜻

이런 커버리지 툴은 어떻게 만들까? 요악하면

바이트코드를 읽어서 코드 커버리지를 위한 부분의 갯수를 세고 

코드가 실행될  때 몇개가 해당 부분을 지나갔는지 센다.

---

## **모자에서 토끼를 꺼내는 마술**

아무것도 없는 Moja에서 “Rabbit”을 꺼내는 마술

Moja.java

```java
public class Moja {
			public String pullOut() {
					return "";
			}
}
```

Masulsa.java

```java
public class Masulsa {

			public static void main(String[] args) {
				System.out.println(new Moja().pullOut());
			}

}
```

---

바이트코드 조작 라이브러리

- ASM: [https://asm.ow2.io/](https://asm.ow2.io/)
    - visitor 패턴과 adaptor패턴을 활용해 사용해야 한다고 함
- Javassist: [https://www.javassist.org/](https://www.javassist.org/)
- ByteBuddy: [https://bytebuddy.net/#/](https://bytebuddy.net/#/)
    - 추천

```java
// https://mvnrepository.com/artifact/net.bytebuddy/byte-buddy
implementation group: 'net.bytebuddy', name: 'byte-buddy', version: '1.12.22'
```

byte buddy 라이브러리 추가

Masulsa.java 변경 (byte buddy이용)

```java
public class Masulsa {
    public static void main(String[] args) {
        try {
            new ByteBuddy().redefine(Moja.class)
                    .method(named("pullOut"))
                    .intercept(FixedValue.value("Rabbit!"))
                    .make()
                    .saveIn(new File("build/classes/java/main/"));
                    // 재 정의한 것의 위치 지정

        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        System.out.println(new Moja().pullOut()); // Rabbit!
    }
}
```

- Moja.class의  pullOut 메서드를 가로채고 “Rabbit!”이라는 고정된 값을 반환하게 만든 후
- 재 정의한 것의 결과물을 저장할 곳 위치 지정
    - 인텔리제이가 build한 결과물은 out 폴더에
    - Gradle이 build한 결과물은 build폴더에 생성 되는 것 같다.
    
![image](https://user-images.githubusercontent.com/70142711/216076288-58a98319-01e3-4051-8b51-5bf810b3ec4b.png)

- 강의와 다르게 Moja.class의 패키지가 딸려오는 것 같다,
    - 그래서 main까지만 경로를 지정함.

```java
public class Moja {
    public Moja() {
    }

    public String pullOut() {
        return "Rabbit!";
    }
}
```

- build 폴더의 Moja.class파일을 보면 위와 같이 바이트 코드가 변경되어 있다.

결과적으로 `소스코드는 “”를 리턴하는데 생성된 바이트코드(class파일)을 보면 “Rabbit!”으로 변경 되어 있다.`

주의점 

`바이트버디 코드`와 `System.out.println(new Moja().pullOut());` 이 코드를 동시에 쓸 수 없다

```java
public class Masulsa {
    public static void main(String[] args) {
        try {
            new ByteBuddy().redefine(Moja.class)
                    .method(named("pullOut"))
                    .intercept(FixedValue.value("Rabbit!"))
                    .make()
                    .saveIn(new File("build/classes/java/main/"));
                    // 재 정의한 것의 위치 지정

        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        System.out.println(new Moja().pullOut()); // Rabbit!
    }
}
```

Masulsa를 실행하면 Masulsa.class, Moja.class로 컴파일되고 그 클래스 파일들이 로딩되고 실행되기 때문에, 그 이후에 바이트버디를 통해서 class 파일을 조작해도 이미 로딩된 클래스 정보 (메소드 영역에 있는) 를 보고 있기 때문에 적용이 안된다

- 바이트 버디 코드가 재 컴파일 하는 것과 유사
- 바이트버디 코드 한번 실행 후 , sout 해야 함

---
전 강의에서 bytebuddy의 `바이트코드 조작하는 코드`와 `조작된 코드`를 같이 실행 할수가 없었다.

```java
public class Masulsa {
    public static void main(String[] args) {
        try {
            new ByteBuddy().redefine(Moja.class) //(1)
                    .method(named("pullOut"))
                    .intercept(FixedValue.value("Rabbit!"))
                    .make()
                    .saveIn(new File("build/classes/java/main/"));
                    // 재 정의한 것의 위치 지정

        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        System.out.println(new Moja().pullOut()); // (2)
    }
}
```

- `(1)` 부분을 실행할 때 Moja.class를 이미 읽었기 때문에, 바이트 코드를 조작하기 전의 클래스가 로딩 된다.
- 그 후에 바이트코드를 변경한다 하더라도 이미 한번 클래스를 읽었기 때문에 `(2)` 출력 시 조작된 바이트코드가 실행되지 않는다.

문자열부터 참조하도록 코드를 변경하면 동시에 실행 할 수가 있다.

```java
public class Masulsa {
    public static void main(String[] args) {
        ClassLoader classLoader = Masulsa.class.getClassLoader();
        TypePool typePool = TypePool.Default.of(classLoader);

        try {
            new ByteBuddy().redefine(
                    typePool.describe("com.whiteship.thejava.bytecode.Moja").resolve(),
                    ClassFileLocator.ForClassLoader.of(classLoader))
                    .method(named("pullOut"))
                    .intercept(FixedValue.value("Rabbit!"))
                    .make()
                    .saveIn(new File("build/classes/java/main/"));
                    // 재 정의한 것의 위치 지정

        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        System.out.println(new Moja().pullOut()); // (2) Rabbit!
    }
}
```

- 위와 같이 코드로 변경하여 조작 시
- `(2)` 코드를 실행하기 전까지는 Moja클래스를 읽지 않아도 되기 때문에
    - 바이트코드 조작으로 클래스 파일이 변경되고 그 후 읽어오게 된다.

- 근데 이 방식도 클래스 로딩 순서에 너무 의존적이기 때문에 이 방식은 삭제
    - Moja클래스를 다른곳 에서 먼저 읽으면 실패 할 것이다.

```java
public class Masulsa {
    public static void main(String[] args) {
        System.out.println(new Moja().pullOut()); 
    }
}
```

Masulsa 클래스는 위와 같이 실행 만 하고 다른 프로젝트에서 바이트 코드 변경

## javaagent 실습

### javaagent란?

JVM에서 동작하는 Java 애플리케이션으로 JVM의 다양한 이벤트를 전달 받거나 특정 API를 이용해 바이트 코드 등을 제어할 수 있다.

- 런타임 시 바이트 코드 조작 가능, JVM의 실행 지점인 `main` 메서드를 가로챌 수 있다.

```java
javaAgent를 이용해서 public static void premain(String agentArgs, Instrumentation inst) {...}을 가진
프로젝트에서 해당 프로젝트를 jar로 maven을 이용해 패키징 한다. 이 jar를 사용할 곳에서 실행 시
javaagent옵션으로 해당 jar를 읽어 들이면 main 메서드 실행 전에 premain을 실행하게 되는 것이다.

하지만 실제 사용하는 측의 바이트 코드는 변경이 되지 않는다. 클래스를 로딩하는 시점에 premain이 적용되기 때문이다.
즉, 사용 측의 어플리케이션이 로딩할 때 premain이 실행되고, 메모리에 저장을 하게 된다.
이렇게 변경을 하여 jar로 패키징을 하였기 때문에 이를 사용하는 프로젝트에서는 바이트 코드와 소스 코드는 Rabbit이 없지만 Rabbit을
꺼낼 수 있게 되는 것이다.

rf)https://dev-monkey-dugi.tistory.com/85#1.1.%20%ED%99%9C%EC%9A%A9%20%EC%98%88
```

Javaagent JAR 파일 만들기

- [https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html](https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html)
    - `문서를 확인하면 premain()` 을 정의 해야 함
- 붙이는 방식은 시작 시 붙이는 방식 premain과 런타임 중에 동적으로 붙이는 방식 agentmain이 있다.
    - premain방식은 애플리케이션 시작 시 javaagent 옵션으로 agent를 붙이는 방식 (premain Class)
    - agentmain 이미 프로세스가 돌고 있을떄 붙이는 방식 (agent Class)

- Instrumentation을 사용한다.
    - premain의 구현메소드를 보면 Instrumentation을 사용 해서 조작한다. Instrumentation의 구현 할 때`asm`또는 `bytebuddy`를 사용해야 한다.
        - 여기선 bytebuddy 사용

Javaagent 붙여서 사용하기

- 클래스 로더가 클래스를 읽어올 때 javaagent를 거쳐서 변경된 바이트 코드를 읽어 들여 사용한다.

MasulsaJavaAgent.java

```java
public class MasulsaAgent {

    public static void premain(String agentArgs, Instrumentation inst) {
        new AgentBuilder.Default()
                .type(ElementMatchers.any())
                .transform((builder, typeDescription, classLoader, javaModule) -> builder.method(named("pullOut")).intercept(FixedValue.value("Rabbit!"))).installOn(inst);
    }

}
```

- **named("pullOut")과 FixedValue.value("Rabbit!")**
    - pullOut의 메서드의 리턴 값을 “Rabbit!” 으로 변경 한다는 의미

이제 jar파일로 패키징 해야 하는데, jar파일 안에 특정 한 값들을 넣어 줘야 한다.

pom.xml

```java
<dependencies>
    <dependency>
      <groupId>net.bytebuddy</groupId>
      <artifactId>byte-buddy</artifactId>
      <version>1.10.1</version>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-jar-plugin</artifactId>
        <version>3.1.2</version>
        <configuration>
          <archive>
            <index>true</index>
            <manifest>
              <addClasspath>true</addClasspath>
            </manifest>
            <manifestEntries>
              <mode>development</mode>
              <url>${project.url}</url>
              <key>value</key>
              <Premain-Class>me.whiteship.MasulsaAgent</Premain-Class>
              <Can-Redefine-Classes>true</Can-Redefine-Classes>
              <Can-Retransform-Classes>true</Can-Retransform-Classes>
            </manifestEntries>
          </archive>
        </configuration>
      </plugin>
    </plugins>
  </build>
```

jar로 묶을때 manifest를 조작 할 수 있는 설정 추가 

아래 페이지 참고

- [https://maven.apache.org/plugins/maven-jar-plugin/examples/manifest-customization.html](https://maven.apache.org/plugins/maven-jar-plugin/examples/manifest-customization.html)

- premain방식을 사용하기 때문에 <manifestEntries>안에 <Premain-Class>를 넣어줘야 함
- `<Can-Redefine-Classes>,<Can-Retransform-Classes>`
    - 클래스를 변경 할때 사용하는 설정

- manifest란?
    
    **Manifest 파일 활용 : 기초**
    
    - JAR 파일은 내부의 manifest 파일을 활용하여 다양한 기능을 지원 (ex. 전자서명, 버전관리, 패키징 등)
    - manifest 파일은 JAR 파일에 패키징된 파일들에 대한 정보를 가지고 있는 특별한 파일
    - manifest 가 가지고 있는 "meta" 정보를 제단하여 JAR 파일을 여러 목적으로 사용 가능
    
    **기본 manifest 이해 (Understanding the Default Manifest)**
    
    (참조 - [Understanding the Default Manifest - Oracle docs](https://docs.oracle.com/javase/tutorial/deployment/jar/defman.html))
    
    - JAR 파일 생성시 자동으로 manifest 파일 생성
    - 항상 META-INF/MANIFEST.MF 경로에 하나의 manifest 파일이 존재
    - 기본 manifest 파일은 Manifest 버전(Manifest-version), 작성자(Created-By) 항목 내용으로 구성
    - "header: value"
    - manifest 파일 정보는 JAR 파일 활용 의도에 따라 항목 추가 가능
    
    cf)[https://tlo-developer.tistory.com/275](https://tlo-developer.tistory.com/275)
    

```java
mvn clean package
```

- 생성된 jar파일의 MATA-INF - MANIFEST.MF를 열어보자

```java
Manifest-Version: 1.0
Created-By: Maven Archiver 3.4.0
Build-Jdk-Spec: 11
Class-Path: byte-buddy-1.10.1.jar
Can-Redefine-Classes: true
Can-Retransform-Classes: true
Premain-Class: me.whiteship.MasulsaAgent
key: value
mode: development
url:
```

위와 같은 값이 들어가 있다. 

Javaagent 적용 (경로는 각자 환경에 맞춰 변경하세요.)

```java
-javaagent:C:\intellijDev\MasulsaAgent\MasulsaAgent\target\MasulsaAgent-1.0-SNAPSHOT.jar
```

참고로 agent 건 실행하는애플리케이션이건 bytebuddy 라이브러리를 다운받은 상태여야 한다.
	
