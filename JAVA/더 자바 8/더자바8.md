# 더자바 8


---

## 1.함수형 인터페이스와 람다

### 함수형 인터페이스와 람다 표현식 소개

```jsx
함수형 인터페이스 (Functional Interface)
 ● 추상 메소드를 딱 하나만 가지고 있는 인터페이스
 ● SAM (Single Abstract Method) 인터페이스
 ● @FuncationInterface 애노테이션을 가지고 있는 인터페이스
람다 표현식 (Lambda Expressions)
 ● 함수형 인터페이스의 인스턴스를 만드는 방법으로 쓰일 수 있다.
 ● 코드를 줄일 수 있다.
 ● 메소드 매개변수, 리턴 타입, 변수로 만들어 사용할 수도 있다.
자바에서 함수형 프로그래밍
 ● 함수를 First class object로 사용할 수 있다.
 ● 순수 함수 (Pure function)
  ○ 사이드 이팩트가 없다. (함수 밖에 있는 값을 변경하지 않는다.)
  ○ 상태가 없다. (함수 밖에 있는 값을 사용하지 않는다.)
 ● 고차 함수 (Higher-Order Function)
  ○ 함수가 함수를 매개변수로 받을 수 있고 함수를 리턴할 수도 있다.
 ● 불변성
```

- js의 함수처럼 보이지만, 실제로는 오브젝트로 볼 수 있음.
- 익명 내부클래스 안에서 외부 변수를 변경 할 수 없다.
    - 참조는 할수 있음, 다만 그경우 해당 변수를 final로 보고, 변경 하려하면 컴파일 에러 발생 한다.

### 자바에서 제공하는 함수형 인터페이스

```jsx
Java가 기본으로 제공하는 함수형 인터페이스
 ● java.lang.funcation 패키지
 ● 자바에서 미리 정의해둔 자주 사용할만한 함수 인터페이스
 ● Function<T, R>
 ● BiFunction<T, U, R>
 ● Consumer<T>
 ● Supplier<T>
 ● Predicate<T>
 ● UnaryOperator<T>
 ● BinaryOperator<T>
---
Function<T, R>
 ● T 타입을 받아서 R 타입을 리턴하는 함수 인터페이스
   ○ R apply(T t)
 ● 함수 조합용 메소드
   ○ andThen
   ○ compose
BiFunction<T, U, R>
 ● 두 개의 값(T, U)를 받아서 R 타입을 리턴하는 함수 인터페이스
   ○ R apply(T t, U u)
Consumer<T>
 ● T 타입을 받아서 아무값도 리턴하지 않는 함수 인터페이스
   ○ void Accept(T t)
 ● 함수 조합용 메소드
   ○ andThen
Supplier<T>
 ● T 타입의 값을 제공하는 함수 인터페이스
   ○ T get()
- 입력 파라미터 없이 받아올때만 사용
Predicate<T>
 ● T 타입을 받아서 boolean을 리턴하는 함수 인터페이스
   ○ boolean test(T t)
 ● 함수 조합용 메소드
   ○ And
   ○ Or
   ○ Negate
UnaryOperator<T>
 ●  Function<T, R>의 특수한 형태로, 입력값 하나를 받아서 동일한 타입을 리턴하는 함수
인터페이스
- Funtion을 상속받았기때문에 Funtion메소드 사용 가능

BinaryOperator<T>
 ● BiFunction<T, U, R>의 특수한 형태로, 동일한 타입의 입렵값 두개를 받아 리턴하는 함수
인터페이스
- 세개의 타입이 전부 동일한경우 임
```

### 람다표현식

```jsx
람다
  ● (인자 리스트) -> {바디}
인자 리스트
  ● 인자가 없을 때: ()
  ● 인자가 한개일 때: (one) 또는 one
  ● 인자가 여러개 일 때: (one, two)
  ● 인자의 타입은 생략 가능, 컴파일러가 추론(infer)하지만 명시할 수도 있다. (Integer one,
Integer two)

바디
  ● 화상표 오른쪽에 함수 본문을 정의한다.
  ● 여러 줄인 경우에 { }를 사용해서 묶는다.
  ● 한 줄인 경우에 생략 가능, return도 생략 가능.

변수 캡처 (Variable Capture)
  ● 로컬 변수 캡처
    ○ final이거나 effective final 인 경우에만 참조할 수 있다.
    ○ 그렇지 않을 경우 concurrency 문제가 생길 수 있어서 컴파일가 방지한다.
  ● effective final
    ○ 이것도 역시 자바 8부터 지원하는 기능으로 “사실상" final인 변수.
    ○ final 키워드 사용하지 않은 변수를 익명 클래스 구현체 또는 람다에서 참조할 수
있다.
  ● 익명 클래스 구현체와 달리 ‘쉐도윙’하지 않는다.
    ○ 익명 클래스는 새로 스콥을 만들지만, 람다는 람다를 감싸고 있는 스콥과 같다.

참고
● https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing
● https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html

```

```java
public class Foo {

    public static void main(String[] args) {
        Foo foo = new Foo();
        foo.run();
    }

    private void run() {

        final int baseNumber = 10;

        // 로컬 클래스
        class LocalClass {
            void printBaseNumber() {
                int baseNumber = 11;
                System.out.println(baseNumber); // 11 쉐도잉 발생
            }
        }
        // 익명 클래스
        Consumer<Integer> IntegerConsumer = new Consumer<Integer>() {
          @Override
          public void accept(Integer baseNumber) {
              System.out.println(baseNumber); // 쉐도잉 발생
            }
        };

        // 람다
        IntConsumer printInt = (i) -> {
						Integer baseNumber = 1; // 컴파일 에러
            System.out.println(i + baseNumber);
        };

        printInt.accept(10);
    }
}
```

- 공통점
    - 내부클래스, 익명클래스, 람다는 final인 경우만 참조 할 수 있다.
    - 자바 8부터는 final을 생략해도 사실상 final인 경우, 즉 변수를 변경 하지 않는 경우 `effective final`라고 한다.
- 차이점
    - 쉐도잉
        - 쉐도잉이란 내부에 스콥이 외부의 스콥을 가린다.
    - 로컬클래스와 익명클래스는 쉐도잉이 된다.
    - 람다는 쉐도잉이 되지 않는다.
        - 람다는 외부와 같은 스콥을 가진다.
        - 같은 이름의 변수를 정의하지 못한다.

### 메소드 레퍼런스

람다가 하는 일이 기존 메소드 또는 생성자를 호출하는 거라면, 메소드 레퍼런스를 사용해서
매우 간결하게 표현할 수 있다.

메소드 참조하는 방법

| 스태틱 메소드 참조 | 타입::스태틱 메소드 |
| --- | --- |
| 특정 객체의 인스턴스 메소드 참조 | 객체 레퍼런스::인스턴스 메소드 |
| 임의 객체의 인스턴스 메소드 참조 | 타입::인스턴스 메소드 |
| 생성자 참조 | 타입::new |
- 메소드 또는 생성자의 매개변수로 람다의 입력값을 받는다.
- 리턴값 또는 생성한 객체는 람다의 리턴 값이다.

참고

- [https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html](https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html)

- 헷갈리는 임의 객체의 인스턴스 메서드참조 | 타입::인스턴스 메소드
- 기선님 답
    - 질문
        
        ```
        springClasses.stream().filter(Predicate.not(OnlineClass::isClosed))
        
        이부분에서
        
        isClosed는 static함수가 아닌데
        그러면 객체::isClosed가 되어야하는거 아닌가요??
        왜 타입::isCloese가 된건가요??
        ```
        
    - 답변
        
        ```java
        메서드 레퍼런스에 총 네가지 형태가 있는데요. 그 중에서 인스턴스 메서드라 하더라도 
        "타입::메서드" 형태로, 지금 예로 들어주신 Online::isClosed와 같이 표현할 수 있는 방법을 
        "임의 객체의 인스턴스 메서드 참조"라고 합니다. 
        말 그대로 "해당 클래스 타입의 어떤 객체가 가지고 있는 해당 메서드"를 가리키는 겁니다. 
        즉, 여기서는 OnlineClass 라는 타입의 객체가 가지고 있는 isClosed 라는 
        인스턴스 메소드를 가리키는 거죠.
        ```
```java
public class Greeting {

    private String name;

    public Greeting() {
    }

    public Greeting(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public String hello(String name) {
        return "hello" + name;
    }

    public static String hi(String name) {
        return "hi" + name;
    }
}
```

위와 같이 메서드가 정의되어 있을 때

```java
public class App {
    public static void main(String[] args) {
        BiFunction<Greeting, String, String> hello = Greeting::hello;
        String test = hello.apply(new Greeting(), "반가워"); // 객체 자동생성하고 메소드 실행후 리턴
        System.out.println(test); // hello반가워
    }
}
```

기선님 답변인 `타입: 인스턴스 메서드인 경우 해당 클래스 타입의 어떤 객체가 가지고 있는 해당메서드를 가리키고 있다.` 는 의미를 완벽히 해석하진 못했지만.

위의 코드와 같이 해당 메소드를 가리키고 있고 BiFuntion으로 해당 람다를 받아 실행하면 

입력된 Greeting타입으로 객체를 생성하여 hello()를 실행하고 그 리턴 값까지 받는다는 것을 알 수 있다.

---
## 인터페이스의 변화

### 인터페이스 기본 메소드와 스태틱 메소드

```jsx
기본 메소드 (Default Methods)
  ● 인터페이스에 메소드 선언이 아니라 구현체를 제공하는 방법
  ● 해당 인터페이스를 구현한 클래스를 깨트리지 않고 새 기능을 추가할 수 있다.
  ● 기본 메소드는 구현체가 모르게 추가된 기능으로 그만큼 리스크가 있다.
    ○ 컴파일 에러는 아니지만 구현체에 따라 런타임 에러가 발생할 수 있다.
    ○ 반드시 문서화 할 것. (@implSpec 자바독 태그 사용)
  ● Object가 제공하는 기능 (equals, hasCode)는 기본 메소드로 제공할 수 없다.
    ○ 구현체가 재정의해야 한다.
  ● 본인이 수정할 수 있는 인터페이스에만 기본 메소드를 제공할 수 있다.
  ● 인터페이스를 상속받는 인터페이스에서 다시 추상 메소드로 변경할 수 있다.
  ● 인터페이스 구현체가 재정의 할 수도 있다.
스태틱 메소드
  ● 해당 타입 관련 헬퍼 또는 유틸리티 메소드를 제공할 때 인터페이스에 스태틱 메소드를
제공할 수 있다.

참고
  ● https://docs.oracle.com/javase/tutorial/java/IandI/nogrow.html
  ● https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html
```

- 두 인터페이스를 구현 했을 때 중복되는 default 메소드가 있다면 자바가 어떤 메소드를 사용할 지 판단할 수 없기 때문에 컴파일 에러 발생
    - 구현체에서 직접 오버라이딩 해줘야 함

### 자바 8 API의 기본 메소드와 스태틱 메소드

```jsx
자바 8에서 추가한 기본 메소드로 인한 API 변화
Iterable의 기본 메소드
  ● forEach()
  ● spliterator()
Collection의 기본 메소드
  ● stream() / parallelStream()
  ● removeIf(Predicate) 
  ● spliterator()
Comparator의 기본 메소드 및 스태틱 메소드
  ● reversed() // 역순 정렬
  ● thenComparing() // Comparing의 조건 추가
  ● static reverseOrder() / naturalOrder()
  ● static nullsFirst() / nullsLast()
  ● static comparing()
참고
  ● https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html
  ● https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html
  ● https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html
  ● https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html
```

- spliterator.trySplit()

```java
public class 자바8_API의_기본_메소드와_스태틱_메소드 {
    public static void main(String[] args) {
        ArrayList<String> name = new ArrayList<>();
        name.add("keesun");
        name.add("whiteship");
        name.add("toby");
        name.add("foo");

        Spliterator<String> spliterator = name.spliterator();      // 아래에서 쪼개 질때 이 spliterator도 반으로 쪼개진다.
        Spliterator<String> spliterator1 = spliterator.trySplit(); // 반으로 쪼개짐
        while (spliterator.tryAdvance(System.out::println));
        System.out.println("====================");
        while (spliterator1.tryAdvance(System.out::println));
        System.out.println();
    }
}
```

- spliterator.trySplit()을 실행하면 기존 iterator가 반으로 줄고, 새로 생성된 Spliterator에 나머지 절반 요소가 들어가게 된다.

```java
toby
foo
====================
keesun
whiteship
```

- 순서는 보장하지 않는다.

인터페이스의 기본 메소드를 통해 구현 메소드를 선택하여 구현할 수 있어 

상속으로 부터 자유로워 졌다.

---

# Stream

## Stream 소개

```java
Stream
  ● sequence of elements supporting sequential and parallel aggregate operations
  ● 데이터를 담고 있는 저장소 (컬렉션)이 아니다.
  ● Funtional in nature, 스트림이 처리하는 데이터 소스를 변경하지 않는다.
  ● 스트림으로 처리하는 데이터는 오직 한번만 처리한다.
  ● 무제한일 수도 있다. (Short Circuit 메소드를 사용해서 제한할 수 있다.)
  ● 중개 오퍼레이션은 근본적으로 lazy 하다.
  ● 손쉽게 병렬 처리할 수 있다.

스트림 파이프라인
  ● 0 또는 다수의 중개 오퍼레이션 (intermediate operation)과 한개의 종료 오퍼레이션
  (terminal operation)으로 구성한다.
  ● 스트림의 데이터 소스는 오직 터미널 오퍼네이션을 실행할 때에만 처리한다.

중개 오퍼레이션
  ● Stream을 리턴한다.
  ● Stateless / Stateful 오퍼레이션으로 더 상세하게 구분할 수도 있다. (대부분은
  Stateless지만 distinct나 sorted 처럼 이전 이전 소스 데이터를 참조해야 하는
  오퍼레이션은 Stateful 오퍼레이션이다.)
  ● filter, map, limit, skip, sorted, ...

종료 오퍼레이션
  ● Stream을 리턴하지 않는다.
  ● collect, allMatch, count, forEach, min, max, ...

참고
● https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html
● https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html
```

```java
ArrayList<String> names = new ArrayList<>();
        names.add("keesun");
        names.add("whiteship");
        names.add("toby");
        names.add("foo");

        names.stream().map((s) -> {
            System.out.println(s); // 실행 되지 않음,
            return s.toUpperCase();
        });
```

- `중개 오퍼레이션은 종료 오퍼레이션이 오기 전까지 실행 되지 않음.`

- Lazy Evaluation
    - 직역하면 "게으른 연산"인데, 연산을 불필요한 연산을 피하기 위해 연산을 지연시키는 것을 말합니다.
    - Lazy 방식은 당장에 해결해야할 문제들이 차례로 주어지더라도 마지막 문제를 제공받을 때 까지 게으르게 기다리다가 마지막 문제를 알게되면, 그때 연산을 시작함으로써 결과를 얻기 위해 필요하지 않은 연산은 수행하지 않게 됩니다.
    - [https://dororongju.tistory.com/137](https://dororongju.tistory.com/137)

- Stream은 Lazy Evaluation을 지원한다.
- 해당 강의에서는 Lazy Evaluation을 말하는게 아닌 `중개 오퍼레이션은 종료 오퍼레이션이 오기 전가지는 정의만 되었을뿐 실행되지 않는다`의 관점이다.

- `손쉽게 병렬처리 할 수 있다.`
    - `parallelStream()` 을 이용하면 개발자가 직접 스레드나 스레드풀을 관리할 필요없이 ForkJoinFramework를 이용하여 작업들을 분할하고 병렬적으로 처리하게 된다.
        - ParallelStream은 개발자로 하여금 편리하게 병렬 연산을 수행할 수 있도록 지원해준다. 하지만 별도의 설정이 없을 경우 기본 쓰레드 풀을모든 ParallelStream에서 공유하게 되므로 이 경우 blocking 작업을 진행할 때 병목현상이 발생할 수 있어 많은 주의가 필요하다.
        - rf) [https://today-hello.tistory.com/157](https://today-hello.tistory.com/157)
        - 데이터가 적으면 쓰레드간 컨텍스트스위칭 비용이 더 커 져 오히려 성능이 감소한다.
        - 그러나 데이터가 매우 방대할 때 유용 하다.
        - 사용할 때 직접 stream과 parallelStream을 사용하면서 성능비교를 해야 함

## Stream API

```java
걸러내기
  ● Filter(Predicate)
  ● 예) 이름이 3글자 이상인 데이터만 새로운 스트림으로
변경하기
  ● Map(Function) 또는 FlatMap(Function)
  ● 예) 각각의 Post 인스턴스에서 String title만 새로운 스트림으로
  ● 예) List<Stream<String>>을 String의 스트림으로
생성하기
  ● generate(Supplier) 또는 Iterate(T seed, UnaryOperator)
  ● 예) 10부터 1씩 증가하는 무제한 숫자 스트림
  ● 예) 랜덤 int 무제한 스트림
제한하기
  ● limit(long) 또는 skip(long)
  ● 예) 최대 5개의 요소가 담긴 스트림을 리턴한다.
  ● 예) 앞에서 3개를 뺀 나머지 스트림을 리턴한다.
스트림에 있는 데이터가 특정 조건을 만족하는지 확인
  ● anyMatch(), allMatch(), nonMatch()
  ● 예) k로 시작하는 문자열이 있는지 확인한다. (true 또는 false를 리턴한다.)
  ● 예) 스트림에 있는 모든 값이 10보다 작은지 확인한다.
개수 세기
  ● count()
  ● 예) 10보다 큰 수의 개수를 센다.
스트림을 데이터 하나로 뭉치기
  ● reduce(identity, BiFunction), collect(), sum(), max()
  ● 예) 모든 숫자 합 구하기
  ● 예) 모든 데이터를 하나의 List 또는 Set에 옮겨 담기
```

- FlatMap()
    - FlatMap()을 이용하여 `List<Stream<String>` 와같은 데이터를 Streaam<String>로 합칠 수 있다.

```java
public static void main(String[] args) {
        List<OnlineClass> springClasses = new ArrayList<>();
        springClasses.add(new OnlineClass(1, "spring boot", true));
        springClasses.add(new OnlineClass(2, "spring data jpa", true));
        springClasses.add(new OnlineClass(3, "spring mvc", false));
        springClasses.add(new OnlineClass(4, "spring core", false));
        springClasses.add(new OnlineClass(5, "rest api development", false));

        System.out.println("spring 으로 시작하는 수업");
        springClasses.stream().filter(oc -> oc.getTitle().startsWith("spring"))
                .forEach(oc -> System.out.println(oc.getId()));

        System.out.println("close 되지 않은 수업");
        springClasses.stream().filter(Predicate.not(OnlineClass::isClosed)) // Predicate.not()로 not표현 가능
                .forEach(oc -> System.out.println(oc.getId()));

        System.out.println("수업 이름만 모아서 스트림 만들기");
        springClasses.stream()
                .map(oc -> oc.getTitle())
                .forEach(System.out::println);

        List<OnlineClass> javaClasses = new ArrayList<>();
        javaClasses.add(new OnlineClass(6, "Thre Java, Test", true));
        javaClasses.add(new OnlineClass(7, "Thre Java, Code manipuliation", true));
        javaClasses.add(new OnlineClass(8, "Thre Java, 8 to 11", false));

        List<List<OnlineClass>> keesunEvents = new ArrayList<>();
        keesunEvents.add(springClasses);
        keesunEvents.add(javaClasses);

        System.out.println("두 수업 목록에 들어있는 모든 수업 아이디 출력");
        keesunEvents.stream()
                .flatMap(Collection::stream) // 스트림 합치기
                .forEach(oc -> System.out.println(oc.getId()));

        System.out.println("10부터 1씩 증가하는 무제한 스트림 중에서 앞에 10개 빼고 최대 10개 까지만");
        Stream.iterate(10, i -> i + 1)
                .skip(10)
                .limit(10)
                .forEach(System.out::println);

        System.out.println("자바 수업 중에 Test가 들어있는 수업이 있는지 확인");
        boolean test = javaClasses.stream().anyMatch(oc -> oc.getTitle().contains("Test"));
        System.out.println(test);

        System.out.println("스프링 수업 중에 제목에 spring이 들어간 제목만 모아서 List로 만들기");
        List<String> spring = springClasses.stream()
                .filter(oc -> oc.getTitle().contains("spring"))
                .map(OnlineClass::getTitle)
                .collect(Collectors.toList());
        spring.forEach(System.out::println);
    }
```

---

## Optional

### Optional 소개

```java
자바 프로그래밍에서 NullPointerException을 종종 보게 되는 이유
  ● null을 리턴하니까! && null 체크를 깜빡했으니까!

메소드에서 작업 중 특별한 상황에서 값을 제대로 리턴할 수 없는 경우 선택할 수 있는 방법
  ● 예외를 던진다. (비싸다, 스택트레이스를 찍어두니까.)
  ● null을 리턴한다. (비용 문제가 없지만 그 코드를 사용하는 클리어인트 코드가 주의해야
  한다.)
  ● (자바 8부터) Optional을 리턴한다. (클라이언트에 코드에게 명시적으로 빈 값일 수도
  있다는 걸 알려주고, 빈 값인 경우에 대한 처리를 강제한다.)

Optional
  ● 오직 값 한 개가 들어있을 수도 없을 수도 있는 컨네이너.

주의할 것
  ● 리턴값으로만 쓰기를 권장한다. (메소드 매개변수 타입, 맵의 키 타입, 인스턴스 필드
  타입으로 쓰지 말자.)
  ● Optional을 리턴하는 메소드에서 null을 리턴하지 말자.
  ● 프리미티브 타입용 Optional을 따로 있다. OptionalInt, OptionalLong,...
  ● Collection, Map, Stream Array, Optional은 Opiontal로 감싸지 말 것.

참고
  ● https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html
  ● https://www.oracle.com/technical-resources/articles/java/java8-optional.html
  ● 이팩티브 자바 3판, 아이템 55 적절한 경우 Optional을 리턴하라.
```

`프리미티브 타입용 Optional을 따로 있다.`

- Optional에 프리미티브 타입을 넣을 순 있지만 내부적으로 박싱, 언박싱이 일어나 성능 상 안 좋다.

`Optional을 리턴하는 메소드에서 null을 리턴하지 말자.`

- Optional.empty()를 리턴하면 된다.

`Collection, Map, Stream Array, Optional은 Opiontal로 감싸지 말 것.`

- 각자 비어있음을 표현할 수 있는 인스턴스이기 때문에 Optional로 감쌀 필요가 없다.

### Optional API

```java
Optional 만들기
  ● Optional.of() 
  ● Optional.ofNullable()
  ● Optional.empty()

Optional에 값이 있는지 없는지 확인하기
  ● isPresent()
  ● isEmpty() (Java 11부터 제공)
Optional에 있는 값 가져오기
  ● get()
  ● 만약에 비어있는 Optional에서 무언가를 꺼낸다면??

Optional에 값이 있는 경우에 그 값을 가지고 ~~를 하라.
  ● ifPresent(Consumer)
  ● 예) Spring으로 시작하는 수업이 있으면 id를 출력하라.

Optional에 값이 있으면 가져오고 없는 경우에 ~~를 리턴하라.
  ● orElse(T)
  ● 예) JPA로 시작하는 수업이 없다면 비어있는 수업을 리턴하라.

Optional에 값이 있으면 가져오고 없는 경우에 ~~를 하라.
  ● orElseGet(Supplier)
  ● 예) JPA로 시작하는 수업이 없다면 새로 만들어서 리턴하라.

Optional에 값이 있으면 가졍고 없는 경우 에러를 던져라.
  ● orElseThrow()

Optional에 들어있는 값 걸러내기
  ● Optional filter(Predicate)

Optional에 들어있는 값 변환하기
  ● Optional map(Function)
  ● Optional flatMap(Function): Optional 안에 들어있는 인스턴스가 Optional인 경우에
  사용하면 편리하다.
```

```java
List<OnlineClass> springClasses = new ArrayList<>();
        springClasses.add(new OnlineClass(1, "spring boot", true));
        springClasses.add(new OnlineClass(5, "rest api development", false));

        Optional<OnlineClass> onlineClass = springClasses.stream()
                .filter(oc -> oc.getTitle().startsWith("jpa"))
                .findFirst();
```

- stream()의 몇 가지 종료 오퍼레이션은 Optional을 리턴 값으로 제공한다.
    - findFirst()종료 오퍼레이션 실행 시 값이 있을지, 없을지 모르기때문에 Optional반환
- null이 아닌게 확실하면  Optional.of() 사용, 아니면 Optional.ofNullable()

`orElse(T)`

```java
public static void main(String[] args) {
        List<OnlineClass> springClasses = new ArrayList<>();
        springClasses.add(new OnlineClass(1, "spring boot", true));
        springClasses.add(new OnlineClass(5, "rest api development", false));

        Optional<OnlineClass> optional = springClasses.stream()
                .filter(oc -> oc.getTitle().startsWith("jpa"))
                .findFirst();

        OnlineClass onlineClass = optional.orElse(createNewClass());
        System.out.println(onlineClass.getTitle()); //New Class

    }

    private static OnlineClass createNewClass() {
        return new OnlineClass(10, "New Class", false);
    }
```

- 해당 Optional의 값이 있으면 리턴, 없으면 orElse안의 값을 리턴(동일한 타입)

`orElseGet`

```java
public static void main(String[] args) {
        List<OnlineClass> springClasses = new ArrayList<>();
        springClasses.add(new OnlineClass(1, "spring boot", true));
        springClasses.add(new OnlineClass(5, "rest api development", false));

        Optional<OnlineClass> optional = springClasses.stream()
                .filter(oc -> oc.getTitle().startsWith("jpa"))
                .findFirst();

        OnlineClass onlineClass = optional.orElseGet(() -> createNewClass());
        System.out.println(onlineClass.getTitle()); // New Class

    }

    private static OnlineClass createNewClass() {
        return new OnlineClass(10, "New Class", false);
    }
```

- orElse()와 다르게 특정 행동을 하는 경우

`Optional에 들어있는 값 걸러내기`

- Optional filter(Predicate)
- 리턴 값은 Optional, 없으면 Optional.empty()를 반환

`Optional에 들어있는 값 변환하기`

- map안의 Fuintion이 리턴하는 타입이 Optional안에 들어간다.

```java
public static void main(String[] args) {
        List<OnlineClass> springClasses = new ArrayList<>();
        springClasses.add(new OnlineClass(1, "spring boot", true));
        springClasses.add(new OnlineClass(5, "rest api development", false));

        Optional<OnlineClass> optional = springClasses.stream()
                .filter(oc -> oc.getTitle().startsWith("spring"))
                .findFirst();

        Optional<OnlineClass> onlineClass = optional.
                filter(oc -> oc.isClosed());
        System.out.println(onlineClass.isPresent()); // true

        Optional<Integer> integer = optional.map(OnlineClass::getId);
        System.out.println(integer.isPresent()); // true
    }
```

`map의 리턴값으로 Optional이 들어가는 경우`

```java
Optional<Optional<Progress>> progress = optional.map(OnlineClass::getProgress);
Optional<Progress> progress1 = progress.orElse(Optional.empty());
```

map의 리턴값이 Optional인 경우 위와 같이 양파 까듯 Optional을 벗겨 사용해야 한다.

```java
Optional<Progress> progress = optional.flatMap(OnlineClass::getProgress);
```

map의 반환 타입이 Optional이면 flatMap이 자동으로 Optional을 벗겨 준다.

- Strema의 flatMap과는 다르니 주의
	
## Date와 Time

### Date와 Time 소개

```java

자바 8에 새로운 날짜와 시간 API가 생긴 이유
  ● 그전까지 사용하던 java.util.Date 클래스는 mutable 하기 때문에 thead safe하지 않다.
  ● 클래스 이름이 명확하지 않다. Date인데 시간까지 다룬다.
  ● 버그 발생할 여지가 많다. (타입 안정성이 없고, 월이 0부터 시작한다거나..)
  ● 날짜 시간 처리가 복잡한 애플리케이션에서는 보통 Joda Time을 쓰곤했다.

자바 8에서 제공하는 Date-Time API
  ● JSR-310 스팩의 구현체를 제공한다.
  ● 디자인 철학
    ○ Clear
    ○ Fluent
    ○ Immutable 
    ○ Extensible

주요 API
  ● 기계용 시간 (machine time)과 인류용 시간(human time)으로 나눌 수 있다.
  ● 기계용 시간은 EPOCK (1970년 1월 1일 0시 0분 0초)부터 현재까지의 타임스탬프를
  표현한다.
  ● 인류용 시간은 우리가 흔히 사용하는 연,월,일,시,분,초 등을 표현한다.
  ● 타임스탬프는 Instant를 사용한다.
  ● 특정 날짜(LocalDate), 시간(LocalTime), 일시(LocalDateTime)를 사용할 수 있다.
  ● 기간을 표현할 때는 Duration (시간 기반)과 Period (날짜 기반)를 사용할 수 있다.
  ● DateTimeFormatter를 사용해서 일시를 특정한 문자열로 포매팅할 수 있다.

참고
  ● https://codeblog.jonskeet.uk/2017/04/23/all-about-java-util-date/
  ● https://docs.oracle.com/javase/tutorial/datetime/overview/index.html
  ● https://docs.oracle.com/javase/tutorial/datetime/iso/overview.html
```

`자바 8에서 제공하는 Date-Time API`

- Immutable (불변, 기존 인스턴스에 값을 변경하면 새로운 인스턴스가 나온다.)

```java
public static void main(String[] args) {
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime localDateTime = now.plusDays(2); //새로운 인스턴스
}
```

### Date와 Time API

**지금 이 순간을 기계 시간으로 표현하는 방법**

- Instant.now(): 현재 UTC (GMT)를 리턴한다.
- Universal Time Coordinated == Greenwich Mean Time

```java
Instant now = Instant.now();
System.out.println(now);
System.out.println(now.atZone(ZoneId.of("UTC")));
ZonedDateTime zonedDateTime = now.atZone(ZoneId.systemDefault());
System.out.println(zonedDateTime);
```

```java
2023-01-24T15:11:01.384549900Z
2023-01-24T15:11:01.384549900Z[UTC]
2023-01-25T00:11:01.384549900+09:00[Asia/Seoul]
```

**인류용 일시를 표현하는 방법**

- LocalDateTime.now(): 현재 시스템 Zone에 해당하는(로컬) 일시를 리턴한다.
- LocalDateTime.of(int, Month, int, int, int, int): 로컬의 특정 일시를 리턴한다.
- ZonedDateTime.of(int, Month, int, int, int, int, ZoneId): 특정 Zone의 특정 일시를 리턴한다.

```java
LocalDateTime now = LocalDateTime.now();
        LocalDateTime birthDay = LocalDateTime.of(1994, Month.MARCH, 10, 0, 0, 0);
        ZonedDateTime nowInKorea = ZonedDateTime.now(ZoneId.of("Asia/Seoul"));
        System.out.println(nowInKorea);

        Instant nowInstant = Instant.now();
        ZonedDateTime zonedDateTime = nowInstant.atZone(ZoneId.of("Asia/Seoul")); 
        //Instant에서 ZonedDateTime 변환 가능
        System.out.println(zonedDateTime);
```

```java
2023-01-25T00:17:43.891304900+09:00[Asia/Seoul]
2023-01-25T00:17:43.892306200+09:00[Asia/Seoul]
```

**기간을 표현하는 방법**

- Period / Duration . beteen()

```java
Period between = Period.between(today, birthDay);
System.out.println(between.get(ChronoUnit.DAYS));
```

**Period**

휴먼용 시간비교

```java
LocalDate today = LocalDate.now();
LocalDate thisYearBirthday = LocalDate.of(2023, Month.MARCH, 10);

Period period = Period.between(today, thisYearBirthday);
System.out.println(period.getYears());
System.out.println(period.getMonths());
System.out.println(period.getDays());

```

```java
0
1
13
// 생일까지 한달 + 13일 남았다. (30 + 13)
```

- 현재 날짜 부터 생일 까지의 기간
- Period는 30일이 초과되면 Month에 담기게 된다.

```java
System.out.println(ChronoUnit.DAYS.between(today, thisYearBirthday));
// 44
```

- ChronoUnit.DAYS.between(현재, 미래)로 Days만 추출 가능.

```java
Period until = today.until(thisYearBirthday);
```

- 다른 방식으론 LocalDate타입에서 until()메서드로 현재부터 미래의 특정 일 까지의 기간을 추출해도 똑같이 Period메서드가 리턴되고 결과도 동일하다.

**Duration**

인스턴트로 비교

```java
Instant now = Instant.now();
Instant plus = now.plus(10, ChronoUnit.SECONDS);
Duration between = Duration.between(now, plus);
System.out.println(between.getSeconds());
```

```java
10 // 10초 차이가 난다.
```

**파싱 또는 포매팅**

- 미리 정의해둔 포맷 참고
- [https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#pre](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#pre)defined
- LocalDateTime.parse(String, DateTimeFormatter)
- Dateteme

```java
DateTimeFormatter formatter =
DateTimeFormatter.ofPattern("MM/d/yyyy");
LocalDate date = LocalDate.parse("07/15/1982", formatter);
System.out.println(date);
System.out.println(today.format(formatter));
```

```java
//포매팅
LocalDateTime now = LocalDateTime.now();
DateTimeFormatter isoLocalDate = DateTimeFormatter.ISO_LOCAL_DATE; //미리 정의되어진 패턴(문서 참조))
DateTimeFormatter MMddyyyy = DateTimeFormatter.ofPattern("MM/dd/yyyy"); //커스텀 패턴

System.out.println(now); // 2023-01-25T01:02:11.677640400
System.out.println(now.format(isoLocalDate)); // 2023-01-25
System.out.println(now.format(MMddyyyy)); // 01/25/2023

// 파싱
LocalDate parse = LocalDate.parse("07/15/1982", MMddyyyy);
System.out.println(parse); // 1982-07-15
```

**레거시 API 지원**

- GregorianCalendar와 Date 타입의 인스턴스를 Instant나 ZonedDateTime으로 변환 가능.
- java.util.TimeZone에서 java.time.ZoneId로 상호 변환 가능.

```java
ZoneId newZoneAPI = TimeZone.getTimeZone("PST").toZoneId();
TimeZone legacyZoneAPI = TimeZone.getTimeZone(newZoneAPI);
Instant newInstant = new Date().toInstant();
Date legacyInstant = Date.from(newInstant);
```

```java
Date date = new Date();
Instant instant = date.toInstant();
Date newDate = Date.from(instant);

GregorianCalendar gregorianCalendar = new GregorianCalendar();
gregorianCalendar.toZonedDateTime();
ZonedDateTime dateTime = gregorianCalendar.toInstant().atZone(ZoneId.systemDefault());
GregorianCalendar from = GregorianCalendar.from(dateTime);

ZoneId zoneId = TimeZone.getTimeZone("PST").toZoneId();
TimeZone timeZone = TimeZone.getTimeZone(zoneId);
```

날짜 더하기

```java
LocalDateTime now1 = LocalDateTime.now();
LocalDateTime plus = now1.plus(10, ChronoUnit.DAYS); 
```

- ChronoUnit기억
- 근데 plusDays()메소드가 이미 지원

---

---

## 7부 CompletableFuture

### 자바 Concurrent 프로그래밍 소개

Concurrent 소프트웨어

- 동시에 여러 작업을 할 수 있는 소프트웨어
- 예) 웹 브라우저로 유튜브를 보면서 키보드로 문서에 타이핑을 할 수 있다.
- 예) 녹화를 하면서 인텔리J로 코딩을 하고 워드에 적어둔 문서를 보거나 수정할 수 있다.

자바에서 지원하는 컨커런트 프로그래밍

- 멀티프로세싱 (ProcessBuilder)
- 멀티쓰레드

자바 멀티쓰레드 프로그래밍

- Thread / Runnable

Thread 상속

```java
public static void main(String[] args) {
		HelloThread helloThread = new HelloThread();
		helloThread.start();
		System.out.println("hello : " + Thread.currentThread().getName());
	}
static class HelloThread extends Thread {
		@Override
		public void run() {
		System.out.println("world : " + Thread.currentThread().getName());
		}
}
```

```java
hello : main
world : Thread-0
```

- 순서를 보장하지 않는다.

Runnable 구현 또는 람다

```java
Thread thread = new Thread(() -> System.out.println("world : " + Thread.currentThread().getName()));
thread.start();
System.out.println("hello : " + Thread.currentThread().getName());
```

쓰레드 주요 기능

- 현재 쓰레드 멈춰두기 (sleep): 다른 쓰레드가 처리할 수 있도록 기회를 주지만 그렇다고
락을 놔주진 않는다. (잘못하면 데드락 걸릴 수 있겠죠.)
- 다른 쓰레드 깨우기 (interupt): 다른 쓰레드를 깨워서 interruptedExeption을 발생 시킨다.
그 에러가 발생했을 때 할 일은 코딩하기 나름. 종료 시킬 수도 있고 계속 하던 일 할 수도
있고.
- 

```java
public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            while (true) {
                System.out.println("Thread: " + Thread.currentThread().getName());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    System.out.println("exit!");
                    return;
                }
            }

        });
        thread.start();
        System.out.println("hello : " + Thread.currentThread().getName());
        Thread.sleep(3000);
        thread.interrupt(); // 3초뒤에 interrupt() 발생
    }
```

```java
Thread: Thread-0
hello : main
Thread: Thread-0
Thread: Thread-0
exit!
```

- interrupt()는 종료시키는게 아닌 일시정지상태를 벗어나게하고 그후의 처리는 처리나름이다.
- 위의 코드의 경우 interrupt()으로 InterruptedException 발생 시 return 으로 작업을 종료

- 다른 쓰레드 기다리기 (join): 다른 쓰레드가 끝날 때까지 기다린다.

```java
public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            System.out.println("Thread: " + Thread.currentThread().getName());
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                throw new IllegalStateException(e);
            }

        });
        thread.start();

        System.out.println("hello : " + Thread.currentThread().getName());

        thread.join(); // main thread는 thread가 끝날때까지 대기
        System.out.println(thread + " is finished");
    }
```

```java
hello : main
Thread: Thread-0
Thread[Thread-0,5,]is finished
```

스레드가 여러 개면 이런 식으로 직접 스레드를 관리하긴 힘들다.

- 이런식으로 코드를 쓰레드를 관리하기 힘들어 Executors를 이용하게 된다.

참고:

● [https://docs.oracle.com/javase/tutorial/essential/concurrency/](https://docs.oracle.com/javase/tutorial/essential/concurrency/)
● [https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#interrupt--](https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#interrupt--)

---

## Executors

고수준 (High-Level) Concurrency 프로그래밍

- 쓰레드를 만들고 관리하는 작업을 애플리케이션에서 분리.
- 그런 기능을 Executors에게 위임.

Executors가 하는 일

- 쓰레드 만들기: 애플리케이션이 사용할 쓰레드 풀을 만들어 관리한다.
- 쓰레드 관리: 쓰레드 생명 주기를 관리한다.
- 작업 처리 및 실행: 쓰레드로 실행할 작업을 제공할 수 있는 API를 제공한다.

주요 인터페이스

- Executor: execute(Runnable)
- ExecutorService: Executor 상속 받은 인터페이스로, Callable도 실행할 수 있으며,
Executor를 종료 시키거나, 여러 Callable을 동시에 실행하는 등의 기능을 제공한다.
- ScheduledExecutorService: ExecutorService를 상속 받은 인터페이스로 특정 시간
이후에 또는 주기적으로 작업을 실행할 수 있다.

ExecutorService로 작업 실행하기

```java
ExecutorService executorService = Executors.newSingleThreadExecutor();
// 방법 1
executorService.execute(new Runnable() {
	  @Override
	  public void run() {
	      System.out.println("Thread " + Thread.currentThread().getName());
	  }
});
// 방법 2
executorService.submit(() -> {
		System.out.println("Hello :" + Thread.currentThread().getName());
});
```

ExecutorService로 멈추기

```java
executorService.shutdown(); // 처리중인 작업 기다렸다가 종료 // graceful shutdown
executorService.shutdownNow(); // 당장 종료 // 
```

- Executor는 작업이 끝났다고 종료되지 않고 다음 작업이 들어올때 까지 계속해서 기다리기 때문에 프로세스가 죽지 않음.
    - shudown()을 명시적으로 해줘야 함.
- 내부적으로 Pool을 가지고 있다.

```java
public class App01 {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(2);
        executorService.submit(getRunnable("Hello"));
        executorService.submit(getRunnable("Keesun"));
        executorService.submit(getRunnable("The"));
        executorService.submit(getRunnable("Java"));
        executorService.submit(getRunnable("Thread"));

        executorService.shutdown();
    }

    private static Runnable getRunnable(String message) {
        return () -> System.out.println(message + Thread.currentThread().getName());
    }
}
```

```java
Hellopool-1-thread-1
Keesunpool-1-thread-2
Thepool-1-thread-1
Javapool-1-thread-1
Threadpool-1-thread-1
```

끝까지 실행 되고, Thread 2개를 가지고 번갈아 가면서 실행

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e01b6d0c-decc-47ac-b756-e0898940b14f/Untitled.png)

ExcutorService안에는 Thread Poll과 Blocking Queue가 존재

- 할당받은 Task를 Queue 넣고 Thread가 번갈아 가며 작업

```java
public class App01 {
    public static void main(String[] args) {
        ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();
//        executorService.schedule(getRunnable("Hello"), 3, TimeUnit.SECONDS);
				// 3초 기다렸다가 실행
        executorService.scheduleAtFixedRate(getRunnable("Hello"), 1, 2, TimeUnit.SECONDS);
				// 1초기다렸다가 2초에 한번씩 실행

//        executorService.shutdown();
				// shutdown()시 InterruptedException()발생 후 종료
    }

    private static Runnable getRunnable(String message) {
        return () -> System.out.println(message + Thread.currentThread().getName());
    }
}
```

Runnable은 리턴타입이 void

Callable은 Runnable과 같지만, 무언가를 리턴 할 수 있다.

리턴값을 받는 게 **Future**

Fork/Join 프레임워크

- ExecutorService의 구현체로 손쉽게 멀티 프로세서를 활용할 수 있게끔 도와준다

참고

- [https://docs.oracle.com/javase/tutorial/essential/concurrency/executors.html](https://docs.oracle.com/javase/tutorial/essential/concurrency/executors.html)

---

### **Callable과 Future**

Callable

- Runnable과 유사하지만 작업의 결과를 받을 수 있다.

Future

- 비동기적인 작업의 현재 상태를 조회하거나 결과를 가져올 수 있다.
- [https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html)

결과를 가져오기 get()

```java
ExecutorService executorService = Executors.newSingleThreadExecutor();
Future<String> helloFuture = executorService.submit(() -> {
			Thread.sleep(2000L);
			return "Callable";
});
System.out.println("Hello");
String result = helloFuture.get(); // 이 시점에서 응답 받을때 까지 기다린다. Blocking Call
System.out.println(result);
executorService.shutdown();
```

- 블록킹 콜이다.
- 타임아웃(최대한으로 기다릴 시간)을 설정할 수 있다.

작업 상태 확인하기 isDone()

- 완료 했으면 true 아니면 false를 리턴한다.

작업 취소하기 cancel()

- 취소 했으면 true 못했으면 false를 리턴한다.
- parameter로 true를 전달하면 현재 진행중인 쓰레드를 interrupt하고 그러지 않으면(false) 현재
진행중인 작업이 끝날때까지 기다린다.
- false를 넣어도 cancel()한 순간 get()으로 가져올 수 없다.

여러 작업 동시에 실행하기 invokeAll()

- 동시에 실행한 작업 중에 제일 오래 걸리는 작업 만큼 시간이 걸린다.

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService executorService = Executors.newSingleThreadExecutor();

        Callable<String> hello = () -> {
            Thread.sleep(2000L);
            return "Hello";
        };

        Callable<String> java = () -> {
            Thread.sleep(3000L);
            return "Java";
        };

        Callable<String> keesun = () -> {
            Thread.sleep(1000L);
            return "Keesun";
        };

        List<Future<String>> futures = executorService.invokeAll(Arrays.asList(hello, java, keesun));
        for (Future<String> f : futures) {
            System.out.println(f.get()); // 실행시간이 제일 긴 3초간 기다렸다가 가져온다.
        }

        executorService.shutdown();
    }
```

```java
Hello
Java
Keesun 
// 3초간 기다렸다가 한번에 출력 됨
```

여러 작업 중에 하나라도 먼저 응답이 오면 끝내기 invokeAny()

- 동시에 실행한 작업 중에 제일 짧게 걸리는 작업 만큼 시간이 걸린다.
- 블록킹 콜이다.
- ex)동일한 파일을 세개의 서버에 가져올때 하나의 파일만 가져오면 작업이 완수되는 경우 사용

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService executorService = Executors.newFixedThreadPool(3); 

        Callable<String> hello = () -> {
            Thread.sleep(2000L);
            return "Hello";
        };

        Callable<String> java = () -> {
            Thread.sleep(3000L);
            return "Java";
        };

        Callable<String> keesun = () -> {
            Thread.sleep(1000L);
            return "Keesun";
        };

        String s = executorService.invokeAny(Arrays.asList(hello, java, keesun));
        System.out.println(s);

        executorService.shutdown();
    }
```

```java
Keesun
```

- 가장 짧은 작업인 Keesun이 찍힌다.
- invokeAny()는 Future가 아닌 String을 바로 리턴한다.
- 이 경우 쓰레드가 최소 3개는 있어야 동시에 작업이 실행되기 때문에, Keesun이 찍히는걸 볼 수있음.
    - 쓰레드가 한개면 하나씩 실행됨.

---

### CompletableFuture 1

- 자바 8에 도입

자바에서 비동기(Asynchronous) 프로그래밍을 가능케하는 인터페이스

- Future를 사용해서도 어느정도 가능했지만 하기 힘들 일들이 많았다

Future로는 하기 어렵던 작업들

- Future를 외부에서 완료 시킬 수 없다. 취소하거나, get()에 타임아웃을 설정할 수는 있다.
- 블로킹 코드(get())를 사용하지 않고서는 작업이 끝났을 때 콜백을 실행할 수 없다.
- 여러 Future를 조합할 수 없다, 예) Event 정보 가져온 다음 Event에 참석하는 회원 목록
가져오기
- 예외 처리용 API를 제공하지 않는다

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService executorService = Executors.newFixedThreadPool(4);
        Future<String> future = executorService.submit(() -> "hello");

        future.get();
        // 값을 가져와 사용하려면 blocking call이기 때문에 여기부터 사용할 수있음.
    }
```

[CompleteableFuture](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html)

- Implements Future
- Implements [CompletionStage](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html)
    - 외부에서 명시적으로 완료 할 수 있어서 complete가 붙음.
        - ex) 외부에서 몇초안에 결과가 안오면 특정한 값 리턴하게

명시적으로 Excutor를 만들어서 사용할 필요가 없음. 

- CompleteableFuture만 가지고 비동기적인 작업을 실행할 수있음.

```jsx
CompletableFuture<String> future = new CompletableFuture<>();
future.complete("keesun"); // future의 기본 값 지정

System.out.println(future.get()); // keesun
```

- CompletableFuture를 사용해도 get은 써야함

```jsx
CompletableFuture<String> future = CompletableFuture.completedFuture("keesun");
System.out.println(future.get()); // keesun
```

- Static Factory method를 사용해도 된다.

- future만 정의한다고 실행되지 않음, get()이나 join()을 해야함
    - join()은 future안에서 발생하는 에러를 UnCheckException으로 던져준다.
        - 예외처리를 따로 안해도 됨

비동기로 작업 실행하기

- 리**턴값이 없는 경우: runAsync()**

```java
CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
    System.out.println("Hello " + Thread.currentThread().getName());
});
future.get(); // Hello ForkJoinPool.commonPool-worker-3
```

- **리턴값이 있는 경우: supplyAsync()**

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {

        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            System.out.println("Hello " + Thread.currentThread().getName());
            return "Hello";
        });

        System.out.println(future.get());

    }
// Hello ForkJoinPool.commonPool-worker-3
// Hello
```

- 원하는 Executor(쓰레드풀)를 사용해서 실행할 수도 있다. (기본은
ForkJoinPool.commonPool())

콜백 제공하기

- **thenApply(Function): 리턴값을 받아서 다른 값으로 바꾸는 콜백**

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {

        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            System.out.println("Hello " + Thread.currentThread().getName());
            return "Hello";
        }).thenApply((s) -> {
            System.out.println(Thread.currentThread().getName());
            return s.toUpperCase();
        });

        System.out.println(future.get()); // HELLO
    }
```

```java
Hello ForkJoinPool.commonPool-worker-3
ForkJoinPool.commonPool-worker-3
HELLO
```

- **thenAccept(Consumer): 리턴값을 또 다른 작업을 처리하는 콜백 (리턴없이)**

```java
CompletableFuture<Void> future = CompletableFuture.supplyAsync(() -> {
    System.out.println("Hello " + Thread.currentThread().getName());
    return "Hello";
}).thenAccept((s) -> {
    System.out.println(Thread.currentThread().getName());
});

future.get();
```

- thenRun(Runnable): 리턴값 받지 않고, 다른 작업만 처리하는 콜백
- 

- 스레드 풀을 만들지도 않고 어떻게 별도의 쓰레드에서 동작을 할까?
    - ForkJoinPool때문에 그렇다
    - Excutors를 사용하지 않아도 내부적으로 기본은 ForkJoinPool.commonPool())을 사용한다.
        - 원한다면  원하는 Executor(쓰레드풀)를 사용해서 실행할 수도 있다. (기본은
        ForkJoinPool.commonPool())

- 그냥 ForkJoinPool사용시

```java
CompletableFuture<Void> future = CompletableFuture.supplyAsync(() -> {
            System.out.println("Hello " + Thread.currentThread().getName());
            return "Hello";
        }).thenRun(() -> {
            System.out.println(Thread.currentThread().getName());
        });

future.get();
```

```java
Hello ForkJoinPool.commonPool-worker-3
ForkJoinPool.commonPool-worker-3
```

- 스레드 풀 사용 시

```java
ExecutorService executorService = Executors.newFixedThreadPool(4);
        CompletableFuture<Void> future = CompletableFuture.supplyAsync(() -> {
            System.out.println("Hello " + Thread.currentThread().getName());
            return "Hello";
        }, executorService).thenRun(() -> {
            System.out.println(Thread.currentThread().getName());
        });

future.get();
```

```java
Hello pool-1-thread-1
pool-1-thread-1
```

ForkJoinPool

- Java 7에서 새로 지원하는 fork-join 풀은 기본적으로 큰 업무를 작은 업무로 나누어 배분해서 , 일을 한 후에 일을 취합하는 형태입니다. 분할 정복 알고리즘과 비슷
- [https://hamait.tistory.com/612](https://hamait.tistory.com/612)

콜백 자체를 또 다른 쓰레드에서 실행할 수 있다.

```java
ExecutorService executorService01 = Executors.newFixedThreadPool(4);
        ExecutorService executorService02 = Executors.newFixedThreadPool(2);
        CompletableFuture<Void> future = CompletableFuture.supplyAsync(() -> {
            System.out.println("Hello " + Thread.currentThread().getName());
            return "Hello";
        }, executorService01).thenRunAsync(() -> {
            System.out.println(Thread.currentThread().getName());
        }, executorService02); // 콜백을 다른 스레드 풀에서 실행
```

```java
Hello pool-1-thread-1
pool-2-thread-1
```

---

### CompletableFuture 2

조합하기

- thenCompose(): 두 작업이 서로 이어서 실행하도록 조합

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    CompletableFuture<String> hello = CompletableFuture.supplyAsync(() -> {
        System.out.println("Hello " + Thread.currentThread().getName());
        return "Hello";
    });

    CompletableFuture<String> future = hello.thenCompose(s -> getWorld(s));
		//A작업과 B작업을 합친 새로운 future 탄생
    System.out.println(future.get());
}

private static CompletableFuture<String> getWorld(String message) {
    return CompletableFuture.supplyAsync(() -> {
        System.out.println("World" + Thread.currentThread().getName());
        return message + "World";
    });
}
```

```java
Hello ForkJoinPool.commonPool-worker-3
WorldForkJoinPool.commonPool-worker-5
HelloWorld
```

- A작업과 B작업중 먼저 작업의 순서가 정해져 있는 경우 (연관관계가 있는 경우)

각자 연관관계가 없이 따로 동작해도 되는 경우

- **thenCombine(): 두 작업을 독립적으로 실행하고 둘 다 종료 했을 때 콜백 실행**

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    CompletableFuture<String> hello = CompletableFuture.supplyAsync(() -> {
        System.out.println("Hello " + Thread.currentThread().getName());
        return "Hello";
    });

    CompletableFuture<String> world = CompletableFuture.supplyAsync(() -> {
        System.out.println("World " + Thread.currentThread().getName());
        return "World";
    });

    CompletableFuture<String> future = hello.thenCombine(world, (h, w) -> h + " " + w);
    System.out.println(future.get());
}
```

```java
Hello ForkJoinPool.commonPool-worker-3
World ForkJoinPool.commonPool-worker-5
Hello World
```

작업이 2개 이상 일때 

- **allOf(): 여러 작업을 모두 실행하고 모든 작업 결과에 콜백 실행**

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
  CompletableFuture<String> hello = CompletableFuture.supplyAsync(() -> {
      System.out.println("Hello " + Thread.currentThread().getName());
      return "Hello";
  });

  CompletableFuture<String> world = CompletableFuture.supplyAsync(() -> {
      System.out.println("World " + Thread.currentThread().getName());
      return "World";
  });

  CompletableFuture<Void> future = CompletableFuture.allOf(hello, world)
          .thenAccept((result) -> {
              System.out.println(result);
          });

  future.get();
```

```java
World ForkJoinPool.commonPool-worker-3
Hello ForkJoinPool.commonPool-worker-5
null
```

- 각 작업들의 리턴 값이 무슨타입인지 모르기때문에 당연히 result는 NULL이다.

- 각 작업의 모든 결과를 List로 추출하는 방법

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
CompletableFuture<String> hello = CompletableFuture.supplyAsync(() -> {
    System.out.println("Hello " + Thread.currentThread().getName());
    return "Hello";
});

CompletableFuture<String> world = CompletableFuture.supplyAsync(() -> {
    System.out.println("World " + Thread.currentThread().getName());
    return "World";
});

List<CompletableFuture<String>> futures = Arrays.asList(hello, world);
CompletableFuture[] futuresArray = futures.toArray(new CompletableFuture[futures.size()]);

CompletableFuture<List<String>> results = CompletableFuture.allOf(futuresArray)
        .thenApply((x) -> {
            return futures.stream() // 이 시점에 모든 future의 작업이 끝나있음
                    .map(f -> f.join()) // join은 uncheckedException을 발생
                    .collect(Collectors.toList());
        });

results.get().forEach(System.out::println);
}
```

```java
Hello ForkJoinPool.commonPool-worker-3
World ForkJoinPool.commonPool-worker-5
Hello
World
```

- **anyOf(): 여러 작업 중에 가장 빨리 끝난 하나의 결과에 콜백 실행**

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<String> hello = CompletableFuture.supplyAsync(() -> {
            System.out.println("Hello " + Thread.currentThread().getName());
            return "Hello";
        });

        CompletableFuture<String> world = CompletableFuture.supplyAsync(() -> {
            System.out.println("World " + Thread.currentThread().getName());
            return "World";
        });

        CompletableFuture<Void> future = CompletableFuture.anyOf(hello, world).thenAccept((s) -> {
            System.out.println(s); // 랜덤하게 Hello, World중 하나가 출력 된다.
        });
        
        future.get(); 
    }
```

예외처리

만약 비동기 작업중 에러가 발생했을때 예외 처리 

- exeptionally(Function)
    - 에러 발생되었을때만 처리된다.

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
		boolean throwError = true;
		
		CompletableFuture<String> hello = CompletableFuture.supplyAsync(() -> {
		    if (throwError) {
		        throw new IllegalArgumentException();
		    }
		
		    System.out.println("Hello " + Thread.currentThread().getName());
		    return "Hello";
		}).exceptionally(ex -> {
		    System.out.println(ex);
		   return "Error!";
		});
		
			System.out.println(hello.get()); // Error! 
}
```

```java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException
Error! 
```

- 

- handle(BiFunction):
    - 예외가 발생한경우, 발생하지않은경우 둘다 처리할수 있다.

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    boolean throwError = true;

    CompletableFuture<String> hello = CompletableFuture.supplyAsync(() -> {
        if (throwError) {
            throw new IllegalArgumentException();
        }

        System.out.println("Hello " + Thread.currentThread().getName());
        return "Hello";
    }).handle((result, ex) -> {
        if (ex != null) {
            System.out.println(ex);
            return "ERROR!";
        }
        return result;
    });

    System.out.println(hello.get());
}
```

```java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException
ERROR!
```

참고

- [https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html)
- [https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html)

-
